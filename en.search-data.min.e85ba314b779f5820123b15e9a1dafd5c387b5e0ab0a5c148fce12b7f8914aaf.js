'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/introduction/build-from-sourcecoude/','title':"Build from the source code",'content':"Build From Source Code\r#\r\r Test machine\r#\r\rubuntu16.04 / go1.13.11\n1. Install dependency libraries and Get the source code\r#\r\r apt-get install -y build-essential apt-get install libboost-all-dev apt-get install libgmp-dev go env -w GO111MODULE=off cd $GOPATH/src/github.com mkdir ZorroChain cd ZorroChain git clone https://github.com/ZorroChain/zorro.git 2. Config library path before start node\r#\r\r  windows  # cmd: set path=%path%;%gopath%\\src\\github.com\\ZorroChain\\zorro\\czk\\czero\\lib_WINDOWS_AMD64 # powershell: $env:path=$env:path+\u0026#34;;\u0026#34;+$env:gopath+\u0026#34;\\src\\github.com\\ZorroChain\\zorro\\czk\\czero\\lib_WINDOWS_AMD64\u0026#34;  mac  export DYLD_LIBRARY_PATH=$GOPATH/src/github.com/ZorroChain/zorro/czk/czero/lib_DARWIN_AMD64  linux  # Linux core v3: export LD_LIBRARY_PATH=$GOPATH/src/github.com/ZorroChain/zorro/czk/czero/lib_LINUX_AMD64_V3 # Linux core v4: export LD_LIBRARY_PATH=$GOPATH/src/github.com/ZorroChain/zorro/czk/czero/lib_LINUX_AMD64_V4 3. Compile zro\r#\r\r cd zorro go install . ./cmd/... You can see that the executable program zro is generated under the path $GOPATH/bin\n4. Start a node or console\r#\r\r  window  zro.exe --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro.exe attach ipc:\\\\.\\pipe\\zro.ipc  mac  zro --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro attach --exchange  linux  zro --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro attach "});index.add({'id':1,'href':'/docs/introduction/','title':"Getting started",'content':""});index.add({'id':2,'href':'/docs/course/service-interface/','title':"Service Interface(SI) Description",'content':"Service Interface (SI) Description\r#\r\r SI services are opened on Zro, enabling third parties to connect to Zro via RPC/Web3 and obtain stateless public chain services.\nSI is used without maintaining public and private keys created by third parties, so third parties need to create and store their own public and private keys and provide them to SI when needed.\nCreateKr\r#\r\r Create public and private keys\n Request   {\u0026quot;id\u0026quot;:0,\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\u0026quot;method\u0026quot;:\u0026quot;ssi_createKr\u0026quot;,\u0026quot;params\u0026quot;:null}\r Successful Response   {\r\u0026quot;SKr\u0026quot;:\u0026quot;0x5bf7d....a0016\u0026quot;, //private key\r\u0026quot;PKr\u0026quot;:\u0026quot;0x904bb....09baa\u0026quot; //public key\r}\r szkCreateKr generates SuperZK2.0 protocal account  GetBlocksInfo\r#\r\r Used to actively synchronize block data\n Request   {\r\u0026quot;id\u0026quot;:0,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_getBlocksInfo\u0026quot;,\r\u0026quot;params\u0026quot;:[\r\u0026quot;0x0\u0026quot;, //starting block\r\u0026quot;0x5\u0026quot; //How many blocks can you get at most\r]\r}\r Successful Response   [\r{\r\u0026quot;Num\u0026quot;:\u0026quot;0x0\u0026quot;, //block number\r\u0026quot;Hash\u0026quot;:\u0026quot;0x2472...2003\u0026quot; //Block Hash\r\u0026quot;Outs\u0026quot;:[\r{\r\u0026quot;Hash\u0026quot;:\u0026quot;0x...\u0026quot; //Tx Hash\r\u0026quot;Root\u0026quot;:\u0026quot;0xfa2e8....5a717\u0026quot;, //the Merkle Root of the Out\r\u0026quot;PKr\u0026quot;: \u0026quot;0xaf630....7ca29\u0026quot; //The temporary public key of the Out\r}\r],\r\u0026quot;Nils\u0026quot;:[\u0026quot;0x...\u0026quot;,...] //cancel code\r},\r...\r]\rDetail\r#\r\r Gets plaintext of the Out\n Request   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_detail\u0026quot;,\r\u0026quot;params\u0026quot;:[\r[\u0026quot;0x...\u0026quot;,\u0026quot;0x...\u0026quot;], //To untangle the root list of plaintext out, you need to have the same PKr\r\u0026quot;0x...\u0026quot; //the Skr corresponds to the Pkr of the Out\r]\r}\r Successful Response   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;result\u0026quot;:[\r{\r\u0026quot;Asset\u0026quot; :{ \u0026quot;Tkn\u0026quot; :{ \u0026quot;Currency\u0026quot;:\u0026quot;0x...\u0026quot;, \u0026quot;Value\u0026quot;:10000000 },\rTkt:{ \u0026quot;Category\u0026quot;:\u0026quot;0x...\u0026quot;, \u0026quot;Value\u0026quot;:\u0026quot;0x...\u0026quot; }\r},\rMemo:\u0026quot;...\u0026quot;, Nil:\u0026quot;0x...\u0026quot; },\r...\r]\r}\rGenTx\r#\r\r To create a transaction, the sender needs to balance Out and In by itself. Note that the more In and Out there are, the longer the transaction takes to generate.\n Request   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_genTx\u0026quot;,\r\u0026quot;params\u0026quot;:[{\rGas: 10000, GasPrice: 1000000000, From: { SKr:\u0026quot;0x...\u0026quot;,\rPKr:\u0026quot;0x...\u0026quot;\r}, Ins: [\r{\rSKr: \u0026quot;0x...\u0026quot;, Root: \u0026quot;0x...\u0026quot; },\r...\r],\rOuts: [\r{\rPKr: \u0026quot;0x...\u0026quot;, Asset: {...}, Memo: \u0026quot;0x.....\u0026quot; },\r...\r]\r}]\r}\r Successful Response   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;result\u0026quot;:\u0026quot;0x...\u0026quot; //the hash of the transaction\r}\rNote\n Zro determines the number of parallel computations based on the performance of the current machine, and the transaction generation time is proportional to the number of UTXO references.  One solution is to merge the recharge UTXO, and another is to extend the timeout of the interface call. --rpcwritetimeout [SECOND] When you start Zro, with this parameter, you can set the timeout in seconds for Zro write-back.    CommitTx\r#\r\r Commit the transaction that has been created.\n Request   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_commitTx\u0026quot;,\r\u0026quot;params\u0026quot;:[\r\u0026quot;0x...\u0026quot; //the hash generated by genTx\r]\r}\r Successful Response   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;result\u0026quot;:null\r}\rSuggested docking solution\r#\r\r  Created by users  Create a different Kr for each user and store it in the database   Recharge:  Keep calling GetBlocksInfo to get the latest block information. Find out if the PKr in the Out of the block is created for itself, and if it is, call the Detail to extract out the clear information and the corresponding invalidation code Nil. Find out if Nil in the block is unchecked in the Detail, if found, the corresponding UTXO has been used.   Withdraw:  Obtain the existing UTXO as In, construct Out, and call GenTx to signature and generate Tx after balancing. Call CommitTx to commit the Tx.    "});index.add({'id':3,'href':'/docs/introduction/operate-in-console/','title':"Console operation",'content':"Console Base Operation\r#\r\r Test machine\r#\r\rubuntu16.04 / go1.13.11\n1. Start the zro console\r#\r\r zro --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro attach 2. Accounts management\r#\r\r Create account\r#\r\r\u0026gt; personal.newAccount(\u0026#34;[PASSWORD]\u0026#34;) ... \u0026#34;[PK]\u0026#34; Where [PASSWORD] is the password for this account, because ZORRO does not store the user\u0026rsquo;s private key. If there is no operation for 5 minutes, the account will be locked. In this case, to transfer the account, you need to use this password to unlock the accout. The command of create user will returns the user\u0026rsquo;s public key. This public key can be used as a transfer address.\nView all public keys\r#\r\r\u0026gt; zorro.accounts ... [\u0026#34;[PK0]\u0026#34;,\u0026#34;[PK1]\u0026#34;,...,\u0026#34;[PKn]\u0026#34;] This command returns the public keys of all accounts in the current wallet.\nUnlock account\r#\r\r\u0026gt; personal.unlockAccount(\u0026#34;[PK]\u0026#34;,\u0026#34;[PASSWORD]\u0026#34;) [PK] is the user\u0026rsquo;s public key\nGet account balance\r#\r\r\u0026gt; zorro.getBalance(\u0026#34;[PK]\u0026#34;) ... {tkn:{...},tkt:{...}} tkn shows all the Tokens balances of the account by category, and tkt shows all the Tickets held by the account by category.\n3. Mining\r#\r\r Start mining\r#\r\r\u0026gt; miner.start() Stop mining\r#\r\r\u0026gt; miner.stop() Console sleep\r#\r\r\u0026gt; admin.sleepBlocks(num) The parameter num is the number of blocks that need to sleep. This method must be invoked when the mining is started, otherwise the system will be blocked constantly. It should be noted that the reward obtained by the mining, by default, will enter the _ public address _ generated _ temporary address (PKr)_ of the 0th account of zorro.accounts.\n4. Generate transactions\r#\r\r When there is already a reward for mining in accounts[0], it can be transferred to another account.\nTransaction command\r#\r\rzorro.sendTransaction({ from:\u0026#34;[SRC_PK]\u0026#34;, to:\u0026#34;[TARGET_PK]\u0026#34;, value:[NUM_OF_TA] }) ... \u0026#34;[TX_ID]\u0026#34; Where [SRC_PK] is the public key of the sender, [TARGET_PK] is the public key of the recipient, [NUM_OF_TA] is the minimum unit amount, the minimum unit of the ZORRO is TA, and the conversion unit is 1 ZORRO = 10^18 TA. The return value [TX_ID] is the ID of the generated transaction.\nAfter the transaction is generated, it will be synchronized to other nodes in the current network, waiting to be packaged into the block. After packing into the block, you can use the following command to get the details of the transaction.\n5. Get transaction details\r#\r\r \u0026gt; zorro.getTransaction(\u0026#34;[TX_ID]\u0026#34;) ...[TX_DETAIL] The main formation of [TX_DETAIL] is as follows:\n{ from: \u0026#34;[SENDER PKr]\u0026#34;, stx: { Desc_Z_Ins: [{ Anchor: \u0026#34;[MERKLE AUTH ROOT]\u0026#34;, AssetCM: \u0026#34;[ASSET COMMITMENT]\u0026#34;, Nil: \u0026#34;[NULLIFIER ID]\u0026#34;, Trace: \u0026#34;[TRACE ID]\u0026#34; Proof: \u0026#34;[ZKP PROOF]\u0026#34; }], Desc_Z_Outs: [{ AssetCM: \u0026#34;[ASSET COMMITMENT]\u0026#34;, OutCM: \u0026#34;[OUTPUT COMMITMENT]\u0026#34;, PKr: \u0026#34;[RECIVER PKr]\u0026#34;, Proof: \u0026#34;[ZKP PROOF]\u0026#34; }], } } "});index.add({'id':4,'href':'/docs/course/exchange-interface/','title':"Exchange Interface(EI) Description",'content':"Exchange Interface (EI) Description\r#\r\r The connection method of the EI interface, the exchange service hosts the user\u0026rsquo;s TK, is responsible for tracking the user\u0026rsquo;s UTXO, and provides online and offline signature methods. Compared with the SSI interface, which requires the peer to manage UTXO itself, EI is simpler, safer, and more practical.\nPlease_note_the_users_and_read_this_article_carefully.\r#\r\r  Seed-\u0026gt; SK-\u0026gt; TK-\u0026gt; PK has a one-to-one correlation, a PK can correlate to a very large number of PKr through random numbers.\n  Each user is associated with a different PKr through a random number, and then associated with a unique PK. There is no need to generate a seed for each user.\n  Please frequently merge the UTXO of the account, otherwise too much UTXO during the transfer will cause the signature time to be too long, which will seriously affect the user experience.\n  Account\r#\r\rAccount by Seed, SK, TK, PK, PKr is composed of four keys, and the generation relationship is as follows:\nseed(seed) -\u0026gt; sk(Private Key) -\u0026gt; TK(Tracking Key) -\u0026gt; PK(Public Key) -\u0026gt; PKr(Receipt Code)\rSeed\r#\r\r seed is a 32-byte BYTE array, which can be generated by HASH algorithm or mnemonic. Having seed can release all subsequent keys, so it must be kept absolutely secure.  sk(Private_Key)\r#\r\r  The Private key SK has a total of 64 BYTE, consisting of two large integers of 32 BYTE, and correlates one-to-one with seed\n sk=(zsk,vsk) \\;\\;zsk \\in Fr, \\; vsk \\in Fr     The private key is used to sign the transaction and also needs to be kept absolutely secure.\n  Can be generated as seed\n  Go Language\n  cpt.ZeroInit_OnlyInOuts() // Initialize the encryption library  var seed keys.Uint256 seed=c_type.RandUint256() sk:=superzk.Seed2Sk( \u0026amp;seed, // Seed 32 Byte Random Number  1 //SuperZK Protocol version 1: SuperZK1.0, 2: SuperZK2.0  )  JS language  const newKeysBySeed = require(\u0026#39;js-zorro-client\u0026#39;).newKeysBySeed let seed = Buffer.alloc( 32, \u0026#39;fd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39;, \u0026#39;hex\u0026#39; ) let keys = newKeysBySeed( seed, //seed Can be used directly as a string (hex|base58)  1 //SuperZK Protocol version 1: SuperZK1.0, 2: SuperZK2.0 ) let sk = keys.sk.toString(\u0026#39;hex\u0026#39;) let tk_hex = keys.tk.toString(\u0026#39;hex\u0026#39;) let tk_base58 = keys.tk.ToBase58() TK(Tracking_Key)\r#\r\r  TK is a 64-length BYTE array consisting of a 32 BYTE ECC_{fp} points and a large integer. The ZPK is the first 32 BYTE of PK, vsk is the last 32 BYTE of sk. One-to-one correlation between TK and sk.\n TK=(ZPK,vsk) \\; ZPK \\in ECC_{fp},\\; vsk \\in Fr    TK can only be used to view the details of UTXO belonging to the account and can be provided to trusted third parties for independent auditing.\n  TK is generated by sk\n  Go language\n  tk:=superzk.Sk2Tk(\u0026amp;sk) //SuperZK1.0/2.0 Can be used  JS language  const newKeysBySk = require(\u0026#39;js-zorro-client\u0026#39;).newKeysBySk let sk = Buffer.alloc( 64, \u0026#39;4e7f432c24d2......e1513eadfef9d1cd604\u0026#39;, \u0026#39;hex\u0026#39; ) let keys = newKeysBySk(sk) //sk Can be used directly as a string (hex|base58)  let tk_hex = keys.tk.toString(\u0026#39;hex\u0026#39;) let tk_base58 = keys.tk.ToBase58() let pk_hex = keys.pk.toString(\u0026#39;hex\u0026#39;) let pk_base58 = keys.pk.ToBase58() PK(Public_Key)\r#\r\r  Public key PK is also 64 BYTE, which consists of two 32 BYTE ECC_{fp}, points, correlates one-to-one with TK\n PK=(ZPK,VPK) \\; ZPK \\in ECC_{fp}, \\; VPK \\in ECC_{fp}    PK is used to generate PKr (Receipt Code). You can provide PK to a third party. PK generates yours PKr (Receipt Code), will then be used to transfer you money and use TK to track the account. However, because of the relationship between safety and performance, it is not recommended to use it directly.\n  PK is generated by TK\n  Go language\n  pk:=superzk.Tk2Pk(\u0026amp;tk) // tk: SuperZK1.0/2.0 Protocol tracking keys  JS language  const newKeysByTk = require(\u0026#39;js-zorro-client\u0026#39;).newKeysByPK let tk = Buffer.alloc( 64, \u0026#39;6a367411b800be76a9d......1ee1513eadfef9d1cd604\u0026#39;, \u0026#39;hex\u0026#39; ) let keys = newKeysByTk(tk) //tk Can be used directly as a string (hex|base58)  let pk_hex = keys.pk.toString(\u0026#39;hex\u0026#39;) let pk_base58 = keys.pk.ToBase58() PKr(Receipt_Code)\r#\r\r  Payment code PKr is a binary data of 96 BYTE, composed of three 32 BYTE ECC_{fp}. You can convert PK and a random number to PKr through keys.Addr2PKr\n PKr=(ZPKr,VPKr,BASEr) \\; ZPKr \\in ECC_{fp}, \\; VPKr \\in ECC_{fp}, \\; BASEr \\in ECC_{fp}    PKr is the target of UTXO. Each PK corresponds to a very large number of PKr. The UTXO pointing to this PKr can be decrypted by TK and signed by sk when in use.\n  PKr is generated by adding a 32 BYTE random number to PK.\n  Go language\n  rnd:=c_superzk.RandomFr() pkr:=superzk.PK2PKr(\u0026amp;pk,\u0026amp;rnd) //SuperZK2.0/1.0 Can be used  JS language  const newKeysByPK = require(\u0026#39;js-zorro-client\u0026#39;).newKeysByPK //SuperZK1.0/2.0 shared  const Czero = require(\u0026#39;js-zorro-client\u0026#39;).Czero let pk = Buffer.alloc( 64, \u0026#39;6a367411b800be......df5fb72aba4019\u0026#39;, \u0026#39;hex\u0026#39; ) let rnd = Czero.RandomU32() let keys = newKeysByPK(pk) //pk Can be used directly as a string (hex|base58)  let pkr = keys.GenPKr(rnd) let pkr_hex = pkr.toString(\u0026#34;hex\u0026#34;) let pkr_base58 = pkr.ToBase58() Interchange between Base58 and Hex encoding in zro console\r#\r\r\u0026gt; web3.addressToHex(zorro.accounts[0]) \u0026#34;0x0dbd9c096......849304201ea6\u0026#34; \u0026gt; web3.hexToBase58(\u0026#34;0x0dbd9c09......9304201ea6\u0026#34;) \u0026#34;GwA94QDTyQ86cE5jcuYCyrQ9Bu9FRcXfq4dxQhryTDzhkahUjYSHcjZ5yFF9bvaZPRMUwR8k5uW4bT3DvPf77a5\u0026#34; Offline_Signature\r#\r\rAfter configuring the transaction in a full node program (zro), you need to use zorro\u0026rsquo;s client for offline signing.\nOffline signing program is also divided into Go version and JS version.\nGo Language\r#\r\rimport \u0026#39;github.com/ZorroChain/zorro/zero/txtool/flight\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/zero/txtool\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/czk/cpt\u0026#39; param_str:=\u0026#39;{\u0026#34;Gas\u0026#34;:25000,\u0026#34;GasPrice\u0026#34;:1000000000,\u0026#34;From\u0026#34;:{\u0026#34;SKr\u0026#34;:\u0026#34;0x0 .... }\u0026#39; // Configured from full nodes sk_str:=\u0026#39;0xfd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; //------ initialization ----- cpt.ZeroInit_OnlyInOuts() // Can only be executed once globally //------txParam--- var param txtool.GTxParam json.Unmarshal([]byte(param_str),\u0026amp;param) //------Private key ---- bs, _ := hexutil.Decode(sk_str) sk := keys.Uint512{} copy(sk[:], bs) //------ Signature ---- gtx, _:=flight.SignTx(sk,param) //------ Convert to JSON ----- tx, _ := json.Marshal(\u0026amp;gtx) Js Language\r#\r\rconst account = require(\u0026#39;js-zorro-client\u0026#39;).Account const tx = require(\u0026#39;js-zorro-client\u0026#39;).Tx //------ const seedStr = \u0026#39;fd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; const txParamStr = \u0026#39;{\u0026#34;Gas\u0026#34;:25000,\u0026#34;GasPrice\u0026#34;:1000000000,\u0026#34;Fro .... }\u0026#39; // Configured from full nodes //------ const seed = Buffer.alloc(32, seedStr, \u0026#39;hex\u0026#39;) const keys = account.NewKeys(seed) const skStr = keys.sk.toString(\u0026#39;hex\u0026#39;) //------ tx.SignTx( txParamStr, skStr, // String hex|base58  (err, tx) =\u0026gt; { if (err) { console.error(err) } else { console.log(tx) } } ) Note\r#\r\r The signature program determines the number of parallel calculations based on the performance of the current machine, and the transaction generation time is proportional to the number of UTXOs referenced.  If you spend a lot of UTXO, the generation time will become very long.   Solution  For online signature applications, merge the incoming UTXO.  zro\u0026rsquo;s exchange service provides automatic merge function, add —autoMerge to zro to automatically merge UTXO.   You can extend the timeout of interface calls.  --rpcwritetimeout [SECOND] Add this parameter when starting zro to set the timeout for zro writeback, in seconds.   For offline signing applications  Run multiple signatures in parallel Use genMergeTx to generate offline signature transaction parameters, and then send them after offline signature.      Import_Account\r#\r\rzro has two ways of importing accounts, namely seed and TK. After importing TK, zro can only be used to track the account balance and recharge records or generate receipt codes. The transactions generated must be submitted to the chain after being signed offline. Importing seed can directly use zro to sign transactions.\n  Import seed\n Import with mnemonic words seed in web3:  \u0026gt; personal.importMnemonic(\u0026#34;uncle frost ex.....ion before\u0026#34;,\u0026#34;123456\u0026#34;) // Mnemonic, password \u0026#34;GwA94QDTyQ86cE5jcu......aZPRMUwR8k5uW4bT3DvPf77a5\u0026#34; // Public key PK  The mnemonic corresponding to the derived seed is  \u0026gt; personal.exportMnemonic(zorro.accounts[0],\u0026#34;123456\u0026#34;) // Public key PK, password \u0026#34;uncle frost expose ...... salmon champion before\u0026#34;  Directly import hex-encoded seed (32 bytes random number)  \u0026gt; personal.importRawKey( \u0026#34;ec8bad429641f......0b1ab03d1f\u0026#34;, //Seed  \u0026#34;123456\u0026#34;, //password  1, // protocol version 1: SuperZK1.0，2: SuperZK2.0  1800000 // Account balance analysis from 1.8 million blocks ) \u0026#34;GwA94QDTyQ86cE5jc......8k5uW4bT3DvPf77a5\u0026#34; // Public key PK  Export hex-encoded seed, need to have this account imported already.  \u0026gt;personal.exportRawKey(\u0026#34;GwA94QDTyQ86cE5j....DvPf77a5\u0026#34;,\u0026#34;123456\u0026#34;) // Public key PK, password  Then use accounts to view the public key of the imported account  \u0026gt; zorro.accounts [\u0026#34;GwA94QDTyQ86cE5jcuYCyrQ9Bu9FRcXfq4dxQhryTDzhkahUjYSHcjZ5yFF9bvaZPRMUwR8k5uW4bT3DvPf77a5\u0026#34;]  Import TK, can only view and track transactions and balances, cannot send transactions.  \u0026gt; personal.importTk( \u0026#34;GwA94QDTyQ86cE5......AwUB22sEmQQ1AguYXn\u0026#34;, //TK  1800000 // Account analysis from 1.8 million blocks ) \u0026#34;GwA94QDTyQ86cE5jcuYCyr......bvaZPRMUwR8k5uW4bT3DvPf77a5\u0026#34; //Public key PK  View of account TK  \u0026gt; zorro.getTk(zorro.accounts[0]) // Public key PK \u0026#34;GwA94QDTyQ86cE5jcuYCy.......AwUB22sEmQQ1AguYXn\u0026#34; //TK  After importing the account, the exchange service will automatically analyze the block information. If it is a newly imported account, the service will take some time to analyze the latest block. You can see if the analysis is complete by looking at zro\u0026rsquo;s logs. You need to open the —exchange mark  INFO [06-13|15:44:00.016] Exchange indexed blockNumber=1031753 INFO [06-13|15:44:50.007] Exchange indexed blockNumber=1031754 INFO [06-13|15:45:00.007] Exchange indexed blockNumber=1031755 INFO [06-13|15:45:10.007] Exchange indexed blockNumber=1031756 Regardless of whether seed or TK is imported, zro will generate a keystore for it, where seed is stored in the form of secret text, TK is stored in clear text.\n  After importing the account, the exchange analysis will start from block 1. In order to avoid too long exchange analysis time, users can:\n By modifying the number of automatically skipped blocks in the keystore file  { \u0026#34;address\u0026#34;:\u0026#34;24DidZ7...KWTQtU8\u0026#34;, \u0026#34;tk\u0026#34;:\u0026#34;24Did...BaG84r\u0026#34;, \u0026#34;crypto\u0026#34;:{ \u0026#34;cipher\u0026#34;:\u0026#34;aes-128-ctr\u0026#34;, \u0026#34;ciphertext\u0026#34;:\u0026#34;4e4b3247...adbff2\u0026#34;, \u0026#34;cipherparams\u0026#34;:{\u0026#34;iv\u0026#34;:\u0026#34;1d13d245...3f9db2\u0026#34;}, \u0026#34;kdf\u0026#34;:\u0026#34;scrypt\u0026#34;, \u0026#34;kdfparams\u0026#34;:{\u0026#34;dklen\u0026#34;:32,\u0026#34;n\u0026#34;:262144,\u0026#34;p\u0026#34;:1,\u0026#34;r\u0026#34;:8,\u0026#34;salt\u0026#34;:\u0026#34;e17991a97...b1b7bd\u0026#34;}, \u0026#34;mac\u0026#34;:\u0026#34;b66f0c...2dd7d06\u0026#34; }, \u0026#34;id\u0026#34;:\u0026#34;f939...28c\u0026#34;, \u0026#34;version\u0026#34;:1, \u0026#34;at\u0026#34;:1050000 // Increase at automatically, skip the previous 1 ~ 1050000 blocks automatically }  Or provide the at parameter when importing the account.    Rpc_version_of_the_offline_interface\r#\r\rCurrently, the offline API interface provides two languages, go and javascript. Other languages ​​can use these functions by starting a zro that is not connected to the outside world through rpc.\n  seed generates sk\nexchange.seed2Sk( \u0026#34;0xec8bad429......0b1ab03d1f\u0026#34;, 1 //SuperZK Protocol version 1：1.0 2：2.0 ) //seed: hex encoding \u0026#34;0x8fe1c73ac......0d1bc4305\u0026#34; //sk: hex encoding   sk generates TK\nexchange.sk2Tk(\u0026#34;0x8fe1c7......40d1bc4305\u0026#34;) //sk: hex encoding \u0026#34;GwA94QDTy......QQ1AguYXn\u0026#34; //TK: base58 encoding   TK generates PK\nexchange.tk2Pk( \u0026#34;GwA94QDTyQ86c......1AguYXn\u0026#34;, //TK: hex or base58 encoding ) \u0026#34;GwA94QDTyQ8......uW4bT3DvPf77a5\u0026#34; //PK: base58 encoding   PK generates PKr\n\u0026gt; exchange.pk2Pkr( \u0026#34;GwA94QDTyQ8......uW4bT3DvPf77a5\u0026#34;, //PK  \u0026#34;0x000000000......0000110\u0026#34; //32 byte The random number is automatically generated if it is empty ) // PK,RNG \u0026#34;22mZ61am......aevRpWMD89\u0026#34; //PKr: base58 encoding   Offline signature\n\u0026gt; const sk = \u0026#39;0xfd1b401d2bbf......71a4b080977\u0026#39; // Private key SK: hex encoding \u0026gt; const txParamObj = {\u0026#34;Gas\u0026#34;:25000,\u0026#34;GasPrice\u0026#34;:1000000000,.... } // Configured by a full node (not a string) \u0026gt; var tx=exchange.signTxWithSk(txParamObj,sk)   Wallet_interface\r#\r\rZORRO\u0026rsquo;s full node program (zro) provides a set of services specifically for exchange listing. Exchange makes third-party listing easier. The listing party can obtain the account-related balance and record information on the chain when only the TK of the account is imported. The interface supports both jsonrpc and console.\nStart the exchange service of the full node (zro)\r#\r\r  Add the startup zro —exchange and --rpcapi exchange,zorro two parameters to open zro of exchange services.\n –exchange Start exchange service --rpcapi zorro,exchange Open the jsonrpc interface of exchange and zorro Other rpc parameters are consistent with Ethereum    In order to ensure security when the computing power fluctuates greatly, the number of confirmed blocks can be set.\n --confirmedBlock 32 Set 32 ​​blocks to confirm the transaction. The default is 12 blocks.    The rpc of ZORRO has a limit on the request size, and the default is 512K.\n --rpcRequestContentLength 1048576 Can change the limit to 1M    If you cannot handle the bigint type when the jsonrpc return value is serialized, you can make jsonrpc return a numeric value as a string.\n --exchangeValueStr Will make zro\u0026rsquo;s jsonrpc interface return the value as a string.    In order to store data on the hard disk as little as possible, zro currently saves snapshots every 10,000 blocks or 1 hour, so when zro is closed, synchronization will start from the nearest integer multiple of 10,000.\n --gcmode archive Will make zro save snapshot data for each block, and will not roll back the block when restarting. But this method will consume more hard disk storage.    When zro has a large number of UTXO signatures, it will take more time to sign, so you can adjust the timeout for zro to write back to the client.\n --rpcwritetimeout [SECOND] Add this parameter when starting zro to set the timeout for zro writeback, in seconds.    Example startup parameters\n The listing party can modify the above configuration according to requirements    ./zro --exchange --datadir ~/zroData --port 53717 --rpc --rpcport 8545 --rpcapi exchange,zorro,net --rpcaddr 127.0.0.1 --rpccorsdomain \u0026#34;*\u0026#34; --keystore ~/keystore --confirmedBlock 32 --rpcwritetimeout 1800 --exchangeValueStr Interface Introduction\r#\r\r  Interface exchange provided by ZORRO\n GetBlockByNumber(num)-\u0026gt;block Get basic information of a block You can also use zorro.GetBlockByNumer to get more detailed information, the usage is compatible with Ethereum GetBlocksInfo(start,end)-\u0026gt;blocks  Get start~end details between blocks   GetPkr(pk,rnd)-\u0026gt;pkr  Generate payment code pkr based on public key pk and random number rnd   GetPkByPkr(pkr)-\u0026gt;pk  Reverse check pk by payment code pkr The corresponding account Pk must be in zro   GetBalances(pk)-\u0026gt;balances  Get the total balance by public key pk   GetRecords(begin,end,[pk])-\u0026gt;[]Utxo  Get the UTXO that the account pk has recharged between the block number begin and end.   GenTx(preTxParam)-\u0026gt;txParam  Get the txParam that can be used for signature through preTxParam.   GenMergeTx(mergeParam)-\u0026gt;txParam  Generate merged transaction parameters txParam based on the parameter mergeParam. txParam requires offline signature.   GetTx(txhash)-\u0026gt;tx  Get details of transaction hash Currently only provide accounting records   GenTxWithSign(preTxParam)-\u0026gt;tx  Generate the signed tx directly through preTxParam Account needs to be imported seed   CommitTx(tx)-\u0026gt;()  Submit the signed tx to the transaction pool and broadcast it to the entire network   GetPkSynced(pk)-\u0026gt;pkState  Get the analysis of current exchange account   Merge(pk,currency)-\u0026gt;txhash  Online signature Automatically merge UTXO of currency The target value is less than 10 UTXO   ValidAddress(pk|pkr)-\u0026gt;bool  Check if PK or PKr is legal   GetLockedBalances(pk)-\u0026gt;lockedState  Check the amount of locks that may result from generating transactions   GetMaxAvailable(pk,currency)-\u0026gt;value  Get the maximum amount that the currency can send   ClearUsedFlag(pk)-\u0026gt;()  Clear UTXO flag locked under PK due to sending transaction   ClearUsedFlagForRoot([root,...])-\u0026gt;()  Clear the lock token of UTXO represented by root      GetBlockByNumber\r#\r\r  Get the current block information according to the block number\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getBlockByNumber\u0026#34;, \u0026#34;params\u0026#34;: [ 109 // Block number, empty means to get the latest block。  ] }    - response\r```javascript\r{\r\u0026quot;id\u0026quot;: 0,\r\u0026quot;result\u0026quot;: {\r\u0026quot;BlockHash\u0026quot;:\u0026quot;0x61de8473709....3172c2225e55\u0026quot;， // Block hash\r\u0026quot;BlockNumber\u0026quot;: 109, // Block number\r\u0026quot;ParentHash\u0026quot;: \u0026quot;0xaf5f6bf0814203a8b49fc3398489e029dd4e9e5da45be241d3f85fc234f341aa\u0026quot;\r\u0026quot;timestamp\u0026quot;: 1561398077 // Timestamp\r\u0026quot;TxHashes\u0026quot;: [ // Transaction hash list\r\u0026quot;0xc31c834efe568d56e7b4c60e7aefe2b223e8567244f242c7870ec5cb47cc1000\u0026quot;, \u0026quot;0x9123159d7016086ed4e1ec253f575cd38f04cc4dea31ce922d1387c985e336c8\u0026quot;\r]\r}\r\u0026quot;error\u0026quot;: null\r}\r console  \u0026gt; exchange.getBlockByNumber(109) { \u0026#34;hash\u0026#34;:\u0026#34;0x61de8473709567be5278c2e607915e6f9001f45f51dc94f8792a3172c2225e55\u0026#34;， \u0026#34;number\u0026#34;: 109, \u0026#34;timestamp\u0026#34;: 1561398077, \u0026#34;TxHashes\u0026#34;: [ \u0026#34;0xc31c834efe568d56e7b4c60e7aefe2b223e8567244f242c7870ec5cb47cc1000\u0026#34;, \u0026#34;0x9123159d7016086ed4e1ec253f575cd38f04cc4dea31ce922d1387c985e336c8\u0026#34; ] } GetBlocksInfo\r#\r\r  Get UTXO usage information for a range of blocks\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getBlocksInfo\u0026#34;, \u0026#34;params\u0026#34;: [ 108, // Starting block number  109 // End block number  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { [ { BlockHash: \u0026#34;0x42fee36......d82bd53\u0026#34;, // Block Hash  Ins: [\u0026#34;0xd85......e0d597\u0026#34;], // UTXO root spent by this block  BlockNumber: 108, // Block height  Outs: [{ Currency: \u0026#34;ZORRO\u0026#34;, Nil: \u0026#34;0xe1d29......d15d89\u0026#34;, Num: 108, Pkr: \u0026#34;0x842e......950d\u0026#34;, Root: \u0026#34;0x192717......646d42a\u0026#34;, TxHash: \u0026#34;0xf8f2269......66d181\u0026#34;, Value: 70000000000000000000 }, ...... ] } ] } \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getBlocksInfo(108,109) { [ { BlockHash: \u0026#34;0x42fee36......d82bd53\u0026#34;, Ins: [\u0026#34;0xd85......e0d597\u0026#34;], BlockNum: 108, Outs: [{ Currency: \u0026#34;ZORRO\u0026#34;, Nil: \u0026#34;0xe1d29......d15d89\u0026#34;, Num: 108, Pkr: \u0026#34;0x842e......950d\u0026#34;, Root: \u0026#34;0x192717......646d42a\u0026#34;, TxHash: \u0026#34;0xf8f2269......66d181\u0026#34;, Value: 70000000000000000000 }, ...... ] } ] } GetPkr\r#\r\r  Create a PKr corresponding to PK with a random number\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getPkr\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c096......32a20849304201ea6\u0026#34;, // PK hex encoding  \u0026#34;0x000000000......00000000000000101\u0026#34; //32 BYTE random number, need\u0026gt; 0x100  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0x8423cdaf21db11......d1c76e728630a882a14\u0026#34;, //PKr  \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getPkr(zorro.accounts[0],\u0026#34;0x000000000......00000000000000100\u0026#34;) \u0026#34;0x4546ffe8932.......88efeead5d7a84\u0026#34; GetPkByPkr\r#\r\r  Get PKr\u0026rsquo;s corresponding PK in zro\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getPkByPkr\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0xa01b191......ad09bf320\u0026#34; // Hex code for receipt code Pkr  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0xc3863f5......bce8168a87\u0026#34;, // Public key PK  \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getPkByPkr(\u0026#34;0xa01b191......ad09bf320\u0026#34;) \u0026#34;0xc3863f5......bce8168a87\u0026#34; GetBalances\r#\r\r  Get the current total balance of the account represented by PK\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getBalances\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c096ca52fa44570......58332a20849304201ea6\u0026#34; // Public key PK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;tkn\u0026#34; : { \u0026#34;ZORRO\u0026#34;: 4000000000000000000 // Currency name: balance  }, \u0026#34;tkt\u0026#34; : {} }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getBalances(web3.addressToHex(zorro.accounts[0])) { ZORRO: 169900000000000000000 } GetRecords\r#\r\r  Get recharge history\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getRecords\u0026#34;, \u0026#34;params\u0026#34;: [ 1, // Starting block number  1000， // End block number  \u0026#34;0x0dbd9c096......849304201ea6\u0026#34;, // Payment Code (PKr) | Account Public Key (PK) | Leave blank  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: [ // Top-up UTXO list  { \u0026#34;Pkr\u0026#34;: \u0026#34;0x67dc2f42a063477a7ef......1fbbfd8707b0cd449994\u0026#34;, \u0026#34;Root\u0026#34;: \u0026#34;0x13ca7a02c8......8e85b08775a3706b0\u0026#34;, // UTXO unique identification  \u0026#34;TxHash\u0026#34;: \u0026#34;0x000000000000000......00000000000000000000\u0026#34;, // The hash of Tx where UTXO is located  \u0026#34;Nil\u0026#34;: \u0026#34;0x902953f4eaec70e......b09beb8fff798a0d59ec23\u0026#34;, // UTXO obsolete code  \u0026#34;Num\u0026#34;: 1, // UTXO block height  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, // Currency name  \u0026#34;Value\u0026#34;: \u0026#34;1000000000000000000\u0026#34; // Number of coins  }, { \u0026#34;Pkr\u0026#34;: \u0026#34;0x291560a9ad4db22df......7bef504d7c7544dbddabcce6e79f0b\u0026#34;, \u0026#34;Root\u0026#34;: \u0026#34;0xa9623b4c88f53e......09522c831bf508834be8a7\u0026#34;, \u0026#34;TxHash\u0026#34;: \u0026#34;0x0dd3a111270......7da11af453498\u0026#34;, \u0026#34;Nil\u0026#34;: \u0026#34;0xa6acfbc53cf68c433......0a1c0b974ad55977048069f\u0026#34;, \u0026#34;Num\u0026#34;: 2, \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, // Currency name  \u0026#34;Value\u0026#34;: \u0026#34;1000000000000000000\u0026#34; // Number of coins  }, ...... ], \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getRecords(1,3,zorro.accounts[0]) [ { Currency: \u0026#34;ZORRO\u0026#34;, Nil: \u0026#34;0x5b3d....b0b328\u0026#34;, Num: 1, Pkr: \u0026#34;0x5e3f88....1ee14\u0026#34;, Root: \u0026#34;0xd79e00....250bc96\u0026#34;, TxHash: \u0026#34;0x000000000......00000000000\u0026#34;, Value: \u0026#34;17600000000000000000\u0026#34; }, ...... ] GenTx\r#\r\r Offline signature version of transaction generation ZORRO has a limit on the number of inputs and outputs of a transaction  No more than 10 in plain text and no more than 500 in secret text No more than 2500 input in plain text, no limitation in secret text input  Can get the maximum amount that can be sent through the API GetMaxAvailable   Every time GenTx is called, UTXO is rotated and the UTXO is written down.  Can query the amount of money that has been locked throught the api GetLockedBalances        jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_genTx\u0026#34;, \u0026#34;params\u0026#34;: [{ \u0026#34;From\u0026#34;: \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, // Account\u0026#39;s PK  \u0026#34;RefundTo\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, // Optional, change receipt code (PKr), if it is empty, it will be generated automatically。  \u0026#34;Gas\u0026#34;: 25000, // Maximum gas consumption, minimum 25000  \u0026#34;GasPrice\u0026#34;: 1000000000, // GasPrice, default 1Gta  \u0026#34;Cmds\u0026#34;: { // Optional, execute command parameters (\u0026gt;=v1.0.0-rc6)  \u0026#34;BuyShare\u0026#34;: { // Purchase of shares (with From as the capital account)  \u0026#34;Value\u0026#34;: \u0026#34;2000000000000000000\u0026#34;, // Purchase amount in Ta  \u0026#34;Vote\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, // SOLO voting address  \u0026#34;Pool\u0026#34;: \u0026#34;0x8414cdd......9df62dbda25b\u0026#34; // Optional, StakingNode ID  }, \u0026#34;Contract\u0026#34;: { // Calling a smart contract  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, // Currency of incoming assets  \u0026#34;Value\u0026#34;: \u0026#34;1000000000\u0026#34;, // Amount of incoming assets, unit Ta  \u0026#34;To\u0026#34;: \u0026#34;0x59bd488f......4e16a2e2b0\u0026#34;, // Contract address. If it is empty, create a smart contract.  \u0026#34;Data\u0026#34;: \u0026#34;0x233892....228efad\u0026#34; // Data for smart contracts  } }, \u0026#34;Receptions\u0026#34;: [{ // Recipient Information  \u0026#34;Addr\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, // Acceptor PKr | PK, PK will be automatically converted to PKr  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, // Currency name  \u0026#34;Value\u0026#34;: 900000000000000000 // Number of coins  }], \u0026#34;Roots\u0026#34;: [] // Which UTXOs need to be used, null values ​​represent automatic selection  }] }  response   The structure returned by this method is relatively complicated, and the result can be directly passed to the offline client for signature.  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;From\u0026#34;: { \u0026#34;SKr\u0026#34;: \u0026#34;0x00000000......00000000000\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xb28e17a7......ad09bf320\u0026#34; }, \u0026#34;Ins\u0026#34;: [{ \u0026#34;SKr\u0026#34;: \u0026#34;0x00000000......00000000000\u0026#34;, \u0026#34;Out\u0026#34;: { \u0026#34;Root\u0026#34;: \u0026#34;0x13ca7a0......75a3706b0\u0026#34;, \u0026#34;State\u0026#34;: { \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 1, \u0026#34;Out_O\u0026#34;: { \u0026#34;Addr\u0026#34;: \u0026#34;0x67dc2f42a063......b0cd449994\u0026#34;, \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x0000000......0000005345524f\u0026#34;, \u0026#34;Value\u0026#34;: 1000000000000000000 }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x00000000......0000000000\u0026#34; }, \u0026#34;Out_Z\u0026#34;: null, \u0026#34;OutCM\u0026#34;: \u0026#34;0xedfe90dbc76......c7e2454371e22\u0026#34;, \u0026#34;RootCM\u0026#34;: \u0026#34;0xe07a24781......1d037f9412c23\u0026#34; }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x0000000000......000000000000\u0026#34;, \u0026#34;Num\u0026#34;: 1 } }, \u0026#34;Witness\u0026#34;: { \u0026#34;Pos\u0026#34;: \u0026#34;0x1\u0026#34;, \u0026#34;Paths\u0026#34;: [\u0026#34;0xea8a7fa27d4c......565c0ca6bf7a8\u0026#34;, \u0026#34;0x2e6831a00874......35c4d21d5cd07\u0026#34;, \u0026#34;0x7812d8320911.......1435b58078af\u0026#34;, \u0026#34;0x47f3115ed518.......29feed9d623\u0026#34; ...... ], \u0026#34;Anchor\u0026#34;: \u0026#34;0xa9623b4c88......508834be8a7\u0026#34; } }], \u0026#34;Outs\u0026#34;: [{ \u0026#34;PKr\u0026#34;: \u0026#34;0x8423cdaf21d......630a882a14\u0026#34;, \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x000......005345524f\u0026#34;, \u0026#34;Value\u0026#34;: 900000000000000000 }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x000000......0000000\u0026#34; }, { \u0026#34;PKr\u0026#34;: \u0026#34;0xb28e17a7d1d......4b740ad09bf320\u0026#34;, \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x000000......0005345524f\u0026#34;, \u0026#34;Value\u0026#34;: 99975000000000000 }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x00000000......000000000\u0026#34; }] }, \u0026#34;error\u0026#34;: null }   console\n  var txParam = exchange.genTx({ \u0026#34;From\u0026#34;: web3.addressToHex(zorro.accounts[0]), \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;Receptions\u0026#34;: [{ \u0026#34;Addr\u0026#34;: web3.addressToHex(zorro.genPKr(zorro.accounts[1])), \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, \u0026#34;Value\u0026#34;: web3.toTa(1) }], \u0026#34;Roots\u0026#34;: [] }) // txParam returns the same result as jsonrpc GenMergeTx\r#\r\r  Offline signed version of UTXO merge\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_genMergeTx\u0026#34;, \u0026#34;params\u0026#34;: [{ \u0026#34;From\u0026#34;: \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, // Account\u0026#39;s PK  \u0026#34;To\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, // Merge to receipt code (PKr), it will be generated automatically if it is empty。  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, // The name of the currency to be merged  \u0026#34;Zcount\u0026#34;: 100, // Maximum number of secret text UTXO merged  \u0026#34;Left\u0026#34;: 1 // How many UTXOs are left  }] }   response\nsame as genTx\n    console\n  var txParam = exchange.genMergeTx({ \u0026#34;From\u0026#34;: web3.addressToHex(zorro.accounts[0]), \u0026#34;To\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, \u0026#34;Zcount\u0026#34;: 100, \u0026#34;Left\u0026#34;: 1 }) // txParam returns the same result as jsonrpc GetTx\r#\r\r  Get transaction details\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getTx\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0xf8f2269......66d181\u0026#34; // Transaction Hash  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { BlockHash: \u0026#34;0x42fee3......d82bd53\u0026#34;, // Block Hash  BlockNumber: 108, // Block number  Outs: [ { // Out list  Currency: \u0026#34;ZORRO\u0026#34;, //Currency name  PK: \u0026#34;0x40aa8......f4d08a96\u0026#34;, // Account public key  Pkr: \u0026#34;0x924f6b6c......09bf320\u0026#34;, // Receipt code  Root: \u0026#34;0x0d57fa92.....879d811\u0026#34;, //Root  Value: 4999925000000000000 //Amount  }, ...... ], Ins: [ // Root list of transaction input UTXO  \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; ], TxHash: \u0026#34;0xf8f2269......66d181\u0026#34; // Transaction hash  Fee: 25000000000000, //gas fee  Timestamp: 1561442217 // Timestamp of transaction  }, \u0026#34;error\u0026#34;: null }     console\n  \u0026gt; exchange.getTx(\u0026#34;0xf8f2269......66d181\u0026#34;) { BlockHash: \u0026#34;0x42fee3......d82bd53\u0026#34;, BlockNumber: 108, Outs: [ { Currency: \u0026#34;ZORRO\u0026#34;, PK: \u0026#34;0x40aa8......f4d08a96\u0026#34;, Pkr: \u0026#34;0x924f6b6c......09bf320\u0026#34;, Value: 4999925000000000000 }, ...... ], TxHash: \u0026#34;0xf8f2269......66d181\u0026#34; } GenTxWithSign\r#\r\r  Online version of transaction generation\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_genTxWithSign\u0026#34;, \u0026#34;params\u0026#34;: [{ \u0026#34;From\u0026#34;: \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, // Account\u0026#39;s PK  \u0026#34;RefundTo\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, // Change receipt code (PKr), if it is empty, it will be generated automatically.  \u0026#34;Gas\u0026#34;: 25000, // Maximum gas consumption, minimum 25000  \u0026#34;GasPrice\u0026#34;: 1000000000, // GasPrice, default 1Gta  \u0026#34;Receptions\u0026#34;: [{ // Recipient Information  \u0026#34;Addr\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, // Recipient PKr \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, // Currency name  \u0026#34;Value\u0026#34;: 900000000000000000 // Number of coins  }], \u0026#34;Roots\u0026#34;: [] // Which UTXOs need to be used, null values ​​represent automatic selection。  }] }  response The signed data can be directly submitted to CommitTx and sent to the entire network. At the same time, the offline signature results after GenTx are consistent with the result of GenTxWithSign.  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;Gas\u0026#34;: \u0026#34;0x61a8\u0026#34;, \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Tx\u0026#34;: { \u0026#34;Ehash\u0026#34;: \u0026#34;0x59bd488......16a2e2b0\u0026#34;, \u0026#34;From\u0026#34;: \u0026#34;0xb28e17a7......d09bf320\u0026#34;, \u0026#34;Fee\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x00000000000......05345524f\u0026#34;, \u0026#34;Value\u0026#34;: 25000000000000 }, \u0026#34;Sign\u0026#34;: \u0026#34;0x7937304f......8fe12d803\u0026#34;, \u0026#34;Bcr\u0026#34;: \u0026#34;0x576cc80af......fc35a82\u0026#34;, \u0026#34;Bsign\u0026#34;: \u0026#34;0xea0c7a......2aadcb801\u0026#34;, \u0026#34;Desc_Z\u0026#34;: { \u0026#34;Ins\u0026#34;: null, \u0026#34;Outs\u0026#34;: [{ \u0026#34;AssetCM\u0026#34;: \u0026#34;0x23b24db7363......af614d40861f28\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x16653600938......cde422f18ac00\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0xc5740db4......4efa5411d9\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x1f0d1dc5f......df00209c22\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0x8423cda.......630a882a14\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x030d19322......c16ba7104\u0026#34; }, { \u0026#34;AssetCM\u0026#34;: \u0026#34;0x73280eb9......9d6d5f042c\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x92cace7c......1a5a528c\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x8126a4......06607d0ee\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x5fa2c37......5101d8f3\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xb28e1......09bf320\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x026a8c617......829600c\u0026#34; }] }, \u0026#34;Desc_O\u0026#34;: { \u0026#34;Ins\u0026#34;: [{ \u0026#34;Root\u0026#34;: \u0026#34;0x13ca7a0......75a3706b0\u0026#34;, \u0026#34;Nil\u0026#34;: \u0026#34;0xc179f8......9acf98d\u0026#34;, \u0026#34;Sign\u0026#34;: \u0026#34;0xa4ef43839......eb19b6a3701\u0026#34; }], \u0026#34;Outs\u0026#34;: null }, \u0026#34;Desc_Pkg\u0026#34;: { \u0026#34;Create\u0026#34;: null, \u0026#34;Transfer\u0026#34;: null, \u0026#34;Close\u0026#34;: null } }, \u0026#34;Hash\u0026#34;: \u0026#34;0x0dd3a1112......11af453498\u0026#34;, //Transaction Hash  \u0026#34;Roots\u0026#34;: [\u0026#34;0x13ca7a0......75a3706b0\u0026#34;] // Root list of input UTXO v1.0.0-rc7  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; personal.unlockAccount(zorro.accounts[0],\u0026#34;123456\u0026#34;) true \u0026gt; var tx = exchange.genTxWithSign({ \u0026#34;From\u0026#34;: web3.addressToHex(zorro.accounts[0]), \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;Receptions\u0026#34;: [{ \u0026#34;Addr\u0026#34;: \u0026#34;0x4546ffe893......eead5d7a84\u0026#34;, \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, \u0026#34;Value\u0026#34;: web3.toTa(1) }], \u0026#34;Roots\u0026#34;: [] }) // tx is the same as the result returned by jsonrpc CommitTx\r#\r\r  Submit the signed transaction to the transaction pool\n  jsonrpc\n  request\n Consistent with the output of GenTxWithSign    response\n No error indicates that it has been placed in the transaction pool and is waiting for zro to be synchronized to the entire network.    console\n  \u0026gt; exchange.commitTx(tx) // tx is the result of `GenTxWithSign` or offline signing null \u0026gt; zorro.getTransactionReceipt(tx.Hash) { blockHash: \u0026#34;0x780cb2866......d27218ff8e\u0026#34;, blockNumber: 107, contractAddress: null, cumulativeGasUsed: 25000, from: \u0026#34;24WSzZB......gkeQJtGP\u0026#34;, gasUsed: 25000, logs: [], logsBloom: \u0026#34;0x00000000......000000000\u0026#34;, root: \u0026#34;0x06414dcf......78ea7c4218\u0026#34;, status: \u0026#34;0x1\u0026#34;, to: null, transactionHash: \u0026#34;0x1bae9132......7ecd7172d36\u0026#34;, transactionIndex: 0 } GetPkSynced\r#\r\r  The analysis of the exchange\u0026rsquo;s current progress\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getPkSynced\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, //账户的PK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#39;currentBlock\u0026#39;: 121, // Current block height  \u0026#39;currentPKBlock\u0026#39;: 121, // block height analyzed by exchange  \u0026#39;highestBlock\u0026#39;: 121 // Current block height across the network  \u0026#39;utxoCount\u0026#39;: { \u0026#39;ZORRO\u0026#39;:100 // ZORRO current number of UTXO, need to call getBalances first  } }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getPkSynced(\u0026#34;0x0dbd9c0....9304201ea6\u0026#34;) { currentBlock: 121, currentPKBlock: 121, highestBlock: 121 } Merge\r#\r\r  Online signature version of UTXO merged\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_merge\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, // Account\u0026#39;s PK  \u0026#34;ZORRO\u0026#34; // Currency of Merge  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;0x1bae9132......7ecd7172d36\u0026#34; // Transaction Hash generated by Merge  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.merge(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;,\u0026#34;ZORRO\u0026#34;) \u0026#34;0x1bae9132......7ecd7172d36\u0026#34; ValidAddress\r#\r\r  Determine whether PK or PKr is effective\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_validAddress\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; // Account\u0026#39;s PK or PKr  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { true // it is effective  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.validAddress(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;) true GetLockedBalances\r#\r\r  Get locked amount\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getLockedBalances\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; // Account\u0026#39;s PK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;ZORRO\u0026#34;:7000 // Amount that could be locked  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getLockedBalances(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;) { \u0026#34;ZORRO\u0026#34;:7000 } GetMaxAvailable\r#\r\r  Get the maximum amount that can currently be transferred\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getMaxAvailable\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, // Account\u0026#39;s PK  \u0026#34;ZORRO\u0026#34; // Currency name  ] } - response ​```javascript { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: 700000, // Maximum one-time transfer amount \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getMaxAvailable(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, \u0026#34;ZORRO\u0026#34;) 700000 ClearUsedFlag\r#\r\r  Clear lock flag based on pk\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_clearUsedFlag\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; // Account\u0026#39;s PK  ] } - response ​```javascript { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: 3, // Cleared 3 UTXO marks \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.clearUsedFlag(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;) 3 ClearUsedFlagForRoot\r#\r\r Clear lock mark based on UTXO\u0026rsquo;s Root    jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_clearUsedFlagForRoot\u0026#34;, \u0026#34;params\u0026#34;: [ [ \u0026#34;0x13ca7a0......75a3706b0\u0026#34;, //UTXO Root  \u0026#34;0x244ae92......976fa00bc\u0026#34; ] ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: 2, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.clearUsedFlagForRoot([\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;]) null Suggested_Listing_Solution\r#\r\rAccount_management\r#\r\r Account generation  Generated via offline client  Randomly generate a 32bytes seed and save it securely Call the account object of js-zorro-client to generate TK and PK  It is recommended to use the more secure SuperZK2.0 protocol to create accounts       Generated by zro  Generate a new account by calling personal.newAccount in the zro console Export the seed through personal.exportRawKey for safe keeping  You can also save the corresponding keystore file   Get account TK through zorro.getTk Get account PK via zorro.accounts   Account import  Import personal TK by calling personal.importTk through zro console Monitor the analysis of the exchange service through logs    Recharge_monitoring\r#\r\r Call exchange.GetRecords to continuously synchronize new recharge records of the PK according to the block number.  Note: ZORRO is a private public chain. When signing a transaction, the referenced UTXO needs to be proved. If there are more UTXOs referenced in the transaction, the transaction signature time will be very long. Therefore, it is necessary to merge the recharged UTXO daily, so that the user will have a good experience when withdrawing cash. ZORRO provides a method for generating offline and non-offline signature merge UTXO transactions.  Off-line signing GenMergeTx On-line signature Merge      Withdrawal\r#\r\r Configure a preTxParam object (refer to the input of GenTx) Offline signature method  Call GenTx to get the txParam object. Call the txsign method signature of js-zorro-client Get signature results tx   Online signature method  Unlock the account of zro Call GenTxWithSign to generate signed transaction tx   Save the hash value of tx Call CommitTx to submit tx to the full node Call zorro.getTransactionReceipt to scan the completion of the transaction Since UTXO cannot be reused, and genTx will lock the UTXO used this time, it is recommended when generating transactions  Get the maximum amount that can be sent this time through exchange.getMaxAvailable  You need to merge UTXO to ensure that the current amount can be sent   The value obtained by exchange.getMaxAvailable will change each time a transaction is generated, representing the amount that can be sent next time.  Call exchange.getMaxAvailable and exchange.genTx | genTxWithSign in a loop until exchange.getMaxAvailable is 0 Wait for new UTXO to be generated after sending the transaction   If any transaction fails, in addition to repeatedly submitting the transaction, you can clear the lock on these UTXO through exchange.ClearUsedFlag    Automatic_UTXO_Merger\r#\r\r  If it is online signature, you can use\n exchange’s automatic merge function.  Add --autoMerge parameter when starting zro When the account under pk will do automatic UTXO merge regularly   Call the exchange.Merge method in the console to merge manually    The offline signing direction can use exchange.genMergeTx to configure a merge transaction\n The transaction is then sent after being signed offline    "});index.add({'id':5,'href':'/docs/course/','title':"Tutorial",'content':""});index.add({'id':6,'href':'/docs/course/flight-interface/','title':"Flight Interface(FI) Description",'content':"Flight Interface(FI) Description\r#\r\r The FI interface is an upgraded version of SI, supports jsonrpc and console calls, and supports the following features:\n zro does not maintain any keys Provide offline signature scheme User manages UTXO Divided into offline interface (local) and online interface (flight)  Project Docking Solution\r#\r\r  Account Plan (offline)\n Generate random 32byte seeds offline (can be local_genSeed generated through the interface) Save offline by local_seed2Sk generating a private key sk. By local_sk2Tk generating a tracking keys TK provided to the online portion of the system. By local_tk2Pk generating a public key PK, it is provided to some online systems. Pass local_pk2Pkr and random numbers, bind a collection code for each user PKr.    Deposit Detection Program (online)\n Continuously iterative calls to flight_getBlocksInfo obtain block information Determine block.Outs[i].State.OS.Out_O.Addr or block.Outs[i].State.OS.Out_Z.PKr whether it belongs to the bound user.  If it belongs to the bound user, do the following things  Use block.Outs[i] and track the secret key TK as a parameter to call local_decOut out the UTXO data in plain text UTXO Obtain a list of obsolete codes from the extracted data Nils Save UTXO and Nils The UTXO asset recorded data     Determine whether the obsolete code block.Nils already exists in the previously saved UTXO table. If it exists, it indicates that it UTXO has been used.    Send transactions (online and offline)\n Select UTXO the parameters that need to be transferred and the related transfer information structure to call flight_genTxParam and generate txParam. The offline signature method is called with the txParam private key sk as the parameter local_signTxWithSk, generated to be broadcast tx, and recorded txhash. Record the keys in the result of local_signTxWithSk Call flight_commitTx with tx as the parameter to broadcast to the whole network. To continue txhash as a parameter to call flight_getTxReceipt, to get packed block number. After confirming 32 blocks, the flight_getTxReceipt data can be obtained from the successful transaction. In case of disputes, you can take out the keys and call local_confirmOutZ to solve the plaintext data.    Local Interface\r#\r\rThe local interface is an offline jsonrpc interface. Although the zro program needs to be started, in addition to the rpc service, zro does not need to connect externally and synchronize data. Therefore, the following parameters can be used to start the zro service.\n./zro --offline --mineMode --datadir ~ / zroData --nodiscover --rpc --rpcport 8545 --rpcapi local, zorro --rpcaddr 127.0.0.1 --rpccorsdomain \u0026#34; * \u0026#34; --exchangeValueStr Account Management\r#\r\r  Randomly generated seed\nseed needs to be saved offline\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_genSeed\u0026#34;, \u0026#34;params\u0026#34;: [] }  response  { \u0026#34;id\u0026#34;: 0 , \u0026#34;result\u0026#34;: \u0026#34;0xc0bdec98290c5a2895e357a6f96f4f7f98b6750d37e77971a055579e7246c403\u0026#34; // The randomly generated seed, 32byte hex code  \u0026#34;error\u0026#34;: null }  go language  seed:=c_type.RandUint256()   Generate sk from seed\nPrivate key needs to be used offline\n request  { \u0026#34;id\u0026#34;: 0 , \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34; , \u0026#34;method\u0026#34;: \u0026#34;local_seed2Sk\u0026#34; , \u0026#34;params\u0026#34;: [ \u0026#34;0xc0bdec98290c .... 79e7246c403\u0026#34; , // seed seed  1 // SuperZK version, 1: 1.0 2: 2.0, default is 1  ] }  response  { \u0026#34;id\u0026#34;: 0 , \u0026#34;result\u0026#34;: \u0026#34;0x1657f2f6f8a743 ...... 595f96be89b4f03\u0026#34; // Private key sk, 64byte hex encoding.  \u0026#34;error\u0026#34;: null }  go language  sk:=superzk.Seed2Sk ( \u0026amp;seed, 1 // superzk protocol version 1: 1.0 2: 2.0 )   Generate tk from sk\nThe tracking key TK cannot sign transactions, so it can be used online.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_sk2Tk\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x1657f2f6f8....95f96be89b4f03\u0026#34; //Private Key sk  ] }  response  { \u0026#34;id\u0026#34;: 0 , \u0026#34;result\u0026#34;: \u0026#34;tu1nEPYcBwBZm ...... r5Y1cXNAs8Ht4z\u0026#34; // Tracking key tk, 64byte base58 encoding.  \u0026#34;error\u0026#34;: null }  Go language  tk:=superzk.Sk2Tk(\u0026amp;sk)   Generate PK from tk\nPK is a public key, so it can be used online.\n request  { \u0026#34;id\u0026#34;: 0 , \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34; , \u0026#34;method\u0026#34;: \u0026#34;local_tk2Pk\u0026#34; , \u0026#34;params\u0026#34;: [ \u0026#34;tu1nEPYcBwBZ ... 1cXNAs8Ht4z\u0026#34; // Tracking key TK, which can be hex or base58 encoding.  ] }  response  { \u0026#34;id\u0026#34;: 0 , \u0026#34;result\u0026#34;: \u0026#34;tu1nEPYcBwBZm ...... cZojp6obBD87N\u0026#34; // Public key PK, 64byte base58 encoding.  \u0026#34;error\u0026#34;: null }  Go language  pk:=superzk.Tk2Pk(\u0026amp;tk)   Generate PKr from PK PKr is a collection code, which can be used online to identify users.\n request  { \u0026#34;id\u0026#34;: 0 , \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34; , \u0026#34;method\u0026#34;: \u0026#34;local_pk2Pkr\u0026#34; , \u0026#34;params\u0026#34;: [ \u0026#34;tu1nEPYcBwBZ ...... cZojp6obBD87N\u0026#34; , // Public key PK, which can be hex or base58 Code  \u0026#34;0xd7a8cc1c7a1d09575950ca8004e3409ab7a6505b39a8e29783338e5016d8e7d1\u0026#34; // 32 byte random number  ] }  response  { \u0026#34;id\u0026#34; : 0 , \u0026#34;result\u0026#34; : \u0026#34;26fUeqrEbq4qZU ...... MP9ehQLV5frg\u0026#34; // Receiving code PKr, 96byte base58 encoding  \u0026#34;error\u0026#34; : null }  Go language  pkr:=superzk.Pk2PKr(\u0026amp;pk)   UTXO Analysis\r#\r\rFrom the flight_getBlocksInfo obtained block information, you can get the new one UTXO, which UTXO is ciphertext, so you need to use the tracking key TK for analysis. The analysis method local_decOut is also offline.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_decOut\u0026#34;, \u0026#34;params\u0026#34;: [ [{ // Parameter 1: UTXO list to be parsed, from flight_getBlocksInfo \tRoot: \u0026#34;0x7b30cc8 ... .510fbb122e \u0026#34;, State: { Num: 28, OS: { Index: 31, Out_O: { // Out of plain text, and Out_Z will only have one \tAddr: \u0026#34; 0x7c02a05 ... ba6ac83a8 \u0026#34;, Asset: {...}, Memo: \u0026#34;0x0000 ...... 0000\u0026#34; } , Out_Z: { // Out of ciphertext \tAssetCM in ciphertext: \u0026#34;0xa2a0f ...... 745a9\u0026#34;, EInfo: \u0026#34;0x68a9e ..... .b74ecfc493 \u0026#34; , OutCM: \u0026#34; 0xc90dc ...... 90ff58f \u0026#34;, PKr: \u0026#34; 0x9364f11 ...... 14406a3 \u0026#34;, // hex code of payment code PKr \tProof: \u0026#34; 0x0341d67 ...... f941b0d \u0026#34;, RPK: \u0026#34; 0x6230d4 ...... 02b51c2 \u0026#34; } , RootCM: \u0026#34; 0xff107b ...... ebdae30a2 \u0026#34; } , TxHash: \u0026#34;0x921b8 ...... be44829\u0026#34; } }] , \u0026#34;tu1nEPYcBwB ...... 5Y1cXNAs8Ht4z\u0026#34; // Parameter 2: TK corresponding to this UTXO \t] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: [ { Asset: { Tkn: { Currency: \u0026#34;0x00000 ...... 005345524f\u0026#34;, // Currency Name \tValue: \u0026#34;1000000000000000000\u0026#34; // Amount \t} , Tkt: null // Ticket assets, the exchange can ignore it \t} , Memo: \u0026#34;0x0000000 ...... 0000000000\u0026#34; , // Information \tNils: [ // The UTXO obsolete code  \u0026#34;0x5f2324 ...... dda85393\u0026#34;, / / As long as it is encountered during getBlocksInfo, the \u0026#34;0x661f10 ...... 90a6a720\u0026#34; // UTXO is invalid  ] } ] , \u0026#34;error\u0026#34;: null } The following is the Go language version of UTXO analysis\nimport \u0026#39;github.com/ZorroChain/zorro/zero/txtool/flight\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/zero/txtool\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/czk/cpt\u0026#39; //--------- outs_str := \u0026#39;[{Root:\u0026#34;0x7b30cc8....510fbb122e\u0026#34;,....,TxHash:\u0026#34;0x921b8......be44829\u0026#34;}]\u0026#39; tk_str := \u0026#39;0xfd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; //--------- cpt.ZeroInit_OnlyInOuts() //--------- var outs []txtool.Out json.Unmarshal([]byte(outs_str),\u0026amp;outs) //--------- bs, _ := hexutil.Decode(tk_str) tk := keys.Uint512{} copy(tk[:], bs) //--------- douts,_=flight.DecOut(\u0026amp;tk,outs) Offline Signature\r#\r\rAfter calling the flight_genTxParam assembly transaction signature parameters, the private key can be passed in to sk call the offline signature method to local_signTxWithSk generate the final transaction. After the final transaction is generated, it can be called flight_commitTx and broadcast to the entire network.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_signTxWithSk\u0026#34;, \u0026#34;params\u0026#34;: [ { // txParam: the result of flight_genTxParam  \u0026#34;Cmds\u0026#34;: {}, \u0026#34;Fee\u0026#34;: {}, \u0026#34;From\u0026#34;: {}, \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;Ins\u0026#34;: [{}], \u0026#34;Outs\u0026#34;: [{}, {}] }, \u0026#34;0x1657f2f6 ...... f96be89b4f03\u0026#34; // private key SK \t] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { // final transaction, the entire network to be broadcast by flight_commitTx  \u0026#34;Gas\u0026#34;: \u0026#34;0x61a8\u0026#34; , \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Hash\u0026#34;: \u0026#34;0x813f69b7d60fe694ddfd6bec36e2adcba773a4518ee02354bd8f2f339f004a2e\u0026#34;, \u0026#34;Keys\u0026#34;: [ // The ciphertext UTXO parses the secret key and will not be submitted to the chain. It can be saved as confirmation evidence.  \u0026#34;0x8e27d9fd65a178569b852cf71e476073b68c2f241074bbd7be712f145b84ee32\u0026#34;, \u0026#34;0x6d83ce881db4fd68876c9a84f354124a01f94d53e702facb4db8071bc6ae146f\u0026#34; ], \u0026#34;Bases\u0026#34;: [\u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;\u0026#34; ], \u0026#34;Tx\u0026#34;: {} }, \u0026#34;error\u0026#34;: null } You can also use Go language offline signature\nimport \u0026#39;github.com/ZorroChain/zorro/zero/txtool/flight\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/zero/txtool\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/czk/cpt\u0026#39; param_str := \u0026#39;{\u0026#34;Gas\u0026#34; : 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;From\u0026#34;: {\u0026#34; SKr\u0026#34;: \u0026#34;0x0 ....\u0026#34;}}\u0026#39; // configured by a full node sk_str := \u0026#39;0xfd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; //------ cpt.ZeroInit_OnlyInOuts() // Initialization //---- var param txtool.GTxParam json.Unmarshal([] byte(param_str), \u0026amp;stop bs, _ := hexutil.Decode(sk_str) sk := keys.Uint512{} copy(sk[:], bs) // --------- You can assemble SK --------- gtx, _ := flight.SignTx(sk , param) // ------ tx, _ := json.Marshal (\u0026amp;gtx) Confirm Out_Z\r#\r\rWhen signing a transaction, a key will be generated for each Out in Desc_Z, and this Key can be used to local_confirmOutZ reverse the clear text of this UTXO through the interface.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_confirmOutZ\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x8e27d9fd65a17 .... 7be712f145b84ee32\u0026#34;, // Key decryption key, which is returned when signing.  { // Content of  Out_Z AssetCM: \u0026#34;0xb5c26 .... 7bcdaf0425\u0026#34;, EInfo: \u0026#34;0x589fa119 .... 741e562c1\u0026#34;, OutCM: \u0026#34;0xb1908 .... 3e48c14\u0026#34;, PKr: \u0026#34;0x1da430a .... 27b0126\u0026#34;, Proof: \u0026#34;0x03eed61 .. \u0026#34;0xc80da39....3263c2\u0026#34; } ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { Asset: { Tkn: { Currency: \u0026#34;0x000000000....0000005345524f\u0026#34;, Value: \u0026#34;1000\u0026#34; }, Tkt: null }, Memo: \u0026#34;0x0000000....00000000\u0026#34;, Nils: null }, \u0026#34;error\u0026#34;: null }  Go language  dec_out,err:=flight.ConfirmOutZ(\u0026amp;key,\u0026amp;outz) Confirm Out_C\r#\r\rWhen signing a transaction, a key will be generated for each Out_C in Tx1, and this key can be used to local_confirmOutCreverse the clear text of this UTXO through the interface.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_confirmOutC\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x8e27d9fd65a17 .... 7be712f145b84ee32\u0026#34;, // Key decryption key, which is returned when signing.  { // Content of  Out_C AssetCM: \u0026#34;0xb5c26 .... 7bcdaf0425\u0026#34;, EInfo: \u0026#34;0x589fa119 .... 741e562c1\u0026#34;, PKr: \u0026#34;0x1da430a .... 27b0126\u0026#34;, Proof: \u0026#34;0x03eed61 .... b24ad9b2a\u0026#34;, RPK: \u0026#34;0xc80da39....3263c2\u0026#34; } ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { Asset: { Tkn: { Currency: \u0026#34;0x000000000....0000005345524f\u0026#34;, Value: \u0026#34;1000\u0026#34; }, Tkt: null }, Memo: \u0026#34;0x0000000....00000000\u0026#34;, Nils: null }, \u0026#34;error\u0026#34;: null }  Go language  dec_out,err:=flight.ConfirmOutC(\u0026amp;key,\u0026amp;outc) Currency name interface\r#\r\rCurrency Id is a 32-byte array, \\0 which can be converted to a string after removing all the previous ones. The offline method also provides a convenient method of mutual conversion.\n** Currency name to currency Id\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_currencyToId\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;ZORRO\u0026#34; // Currency name string  ]  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0x00000000....000005345524f\u0026#34;, // Currency Id \t\u0026#34;error\u0026#34;: null }  Go language  currency_id:=flight.CurrencyToId(currency_str)   Currency Id transfer name\n  request\n  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_idToCurrency\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x00000000....000005345524f\u0026#34; // Currency Id  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;ZORRO\u0026#34;, // Currency name \t\u0026#34;error\u0026#34;: null }  Go language  currency_str:=flight.IdToCurrency(currency_id) Flight interface\r#\r\rThe zro that starts the flight interface needs to synchronize the latest block, which provides online functions.\nThe startup method is:\n./zro --mineMode --datadir ~/zroData --port 53717 --rpc --rpcport 8545 --rpcapi flight,zorro --rpcaddr 127.0.0.1 --rpccorsdomain \u0026#34;*\u0026#34; --keystore ~/keystore --confirmedBlock 32 --rpcwritetimeout 1800 --exchangeValueStr Scan blocks\r#\r\rScan the block to get the new UTXO and UTXO obsolete information in the block, but UTXO in both plain text and cipher text needs to call local_decOut decryption to get more details.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getBlocksInfo\u0026#34;, \u0026#34;params\u0026#34;: [ 15, // start block height  1 // get how many subsequent blocks  ] }  response  { \u0026#34;id\u0026#34;: 0 , \u0026#34;result\u0026#34;: [{ // Block object with height 15 \t\u0026#34;Hash\u0026#34;: \u0026#34;0x33e2cb9 ..... 42e836e3b6b5\u0026#34;, // Block hash \t\u0026#34;Nils\u0026#34;: [ // The area Block invalidation UTXO obsolete code list \t\u0026#34;0x020d0 .... fc504a5\u0026#34;, \u0026#34;0x09f76 .... fe482a6\u0026#34;, \u0026#34;0xd2d8ff3 .... c5b4da6\u0026#34;, \u0026#34;0x51991f8 .... e4380a\u0026#34; ], \u0026#34;Num\u0026#34;: \u0026#34;0xf \u0026#34;, // The height of this block \t\u0026#34; Outs \u0026#34;: [ // The newly generated UTXO list in this block  { // The first UTXO \t\u0026#34; Root \u0026#34;: \u0026#34;0x3f89df0c....300e3572d\u0026#34;, // The UTXO\u0026#39;s Root \t\u0026#34;State\u0026#34;: { \u0026#34;Num\u0026#34;: 15, \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 15, \u0026#34;Out_O\u0026#34;: null, \u0026#34;Out_Z\u0026#34;: { // This UTXO is an anonymous \t\u0026#34;AssetCM\u0026#34;: \u0026#34;0x3defeb .... fbe1ec80\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x218271e .... 190115c0\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x2920 .... ad5faa5\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xe1f .... 09b23\u0026#34;, // The UTXO point to the payment code PKr \t\u0026#34;Proof\u0026#34;:\u0026#34;0x03d8b7e....5c88c2e06\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x44231e....96841\u0026#34; }, \u0026#34;Out_P\u0026#34;: null, \u0026#34;Out_C\u0026#34;: null, }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x482a2....bd0a5c2\u0026#34; } }, { // 2nd UTXO \t\u0026#34;Root\u0026#34;: \u0026#34;0x8d98fe0....fe5bc71f\u0026#34;, \u0026#34;State\u0026#34;: { \u0026#34;Num\u0026#34;: 15, \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 16, \u0026#34;Out_O\u0026#34;: { // This UTXO is in plain text \t\u0026#34;Addr\u0026#34;: \u0026#34;0x7c02a0....ba6ac83a8 \u0026#34;, //The UTXO point to the payment code PKr \t\u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x00000000....000005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;1000025000000000000\u0026#34; }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x0000000....00000000\u0026#34; }, \u0026#34;Out_Z\u0026#34;: null }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x0000000....00000001\u0026#34; } } ], \u0026#34;Pkgs\u0026#34;: null // Package assets, the exchange can ignore \t\u0026#34;error\u0026#34;: null } Get extra information about the block\r#\r\rThis interface can obtain the latest or specified additional information of the block.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getBlockByNumber\u0026#34;, \u0026#34;params\u0026#34;: [ 15 // Block height, empty is to get the latest block  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { BlockHash: \u0026#34;0x33e2cb .... e3b6b5\u0026#34;, // Block Hash  BlockNumber: 15 , // Block Number  Timestamp: 1565153901 , // Timestamp  TxHashes: [ \u0026#34;0x482a2 .. ..1bd0a5c2 \u0026#34; ] // Transaction Hash List  }, \u0026#34; error\u0026#34;: null } Get details of a UTXO\r#\r\rGet UTXO details through UTXO\u0026rsquo;s root\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getOut\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0x7b30cc8....510fbb122e\u0026#34; // Root of a UTXO  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { // UTXO details \tRoot: \u0026#34;0x7b30cc8 .... 510fbb122e\u0026#34;, State: { Num: 28, OS: { // There will only be one Out_O / Out_Z / Out_P / Out_C below \tIndex: 31, Out_O: { //SUPERZK1.0 plain text Out \tAddr: \u0026#34;0x7c02a05 ... ba6ac83a8\u0026#34;, // hex code \tAsset collection code PKr: { ... }, Memo: \u0026#34;0x0000 .. .... 0000 \u0026#34; }, Out_Z: { // Out \tAssetCM in SUPERZK1.0 ciphertext: \u0026#34;0xa2a0f ...... 745a9\u0026#34;, EInfo: \u0026#34;0x68a9e ...... b74ecfc493\u0026#34;, OutCM: \u0026#34;0xc90dc ...... 90ff58f \u0026#34;, PKr: \u0026#34; 0x9364f11 ...... 14406a3 \u0026#34;, // hex code of payment code PKr \tProof: \u0026#34; 0x0341d67 ...... f941b0d \u0026#34;, RPK: \u0026#34; 0x6230d4 ...... 02b51c2 \u0026#34; }, Out_P: { //SUPERZK2.0 plain text Out  Asset: { ... } , Memo:\u0026#34; 0x00000 .... 000000\u0026#34;, PKr: \u0026#34;0x77305 .... 6bce36e\u0026#34; // hex code of payment code PKr  }, Out_C: { //SUPERZK2.0 ciphertext Out  AssetCM: \u0026#34;0xd3be8490 .... 12904aa09 \u0026#34;, EInfo: \u0026#34; 0xd42e33 .... b46e1cd3 \u0026#34;, PKr: \u0026#34; 0xcc0c3b71 .... d7fcbd3 \u0026#34;, // hex code of receipt code PKr  Proof: \u0026#34; 0x02a04a89 .... ede4dca72f \u0026#34;, RPK: \u0026#34; 0x855ba .. ..352e88021 \u0026#34; }, RootCM: \u0026#34; 0xff107b ...... ebdae30a2 \u0026#34; }, TxHash:\u0026#34;0x921b8......be44829\u0026#34; // Transaction Hash\t} \t}, \u0026#34;error\u0026#34;: null } Get original transaction details\r#\r\rObtain the original transaction message through the transaction hash, that is, the signed transaction structure. This transaction structure cannot be used as the basis for final entry.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getTx\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x482a2f......1bd0a5c2\u0026#34; //Transaction Hash  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { // raw transaction information \t\u0026#34;Gas\u0026#34;: \u0026#34;0x15f90\u0026#34;, \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Hash\u0026#34;: \u0026#34;0x482a2 ...... d0a5c2\u0026#34;, \u0026#34;Tx\u0026#34;: { \u0026#34;Bcr\u0026#34;: \u0026#34;0x3334c5 ...... 9ffe532e\u0026#34;, \u0026#34;Bsign\u0026#34;: \u0026#34; 0xa9045b3 ...... 03d3c4503\u0026#34;, \u0026#34;Desc_Cmd\u0026#34;: { // Execution command description, the exchange can ignore \t\u0026#34;BuyShare\u0026#34;: null, \u0026#34;ClosePool\u0026#34;: null, \u0026#34;Contract\u0026#34;: null, \u0026#34;RegistPool\u0026#34;: null } , \u0026#34;Desc_O\u0026#34;: { \u0026#34;Ins\u0026#34;: [ { // clear input \t\u0026#34;Nil\u0026#34;: \u0026#34;0x020d0 ...... c504a5\u0026#34;, \u0026#34;Root\u0026#34;: \u0026#34;0x09f765 ...... 5fe482a6 \u0026#34;, \u0026#34; Sign \u0026#34;: \u0026#34; 0xcde0ef ...... c05e1b3b02 \u0026#34; }] , \u0026#34;Outs\u0026#34;: [ ] // Clear text output, only used for smart contracts, exchange ignores \t} , \u0026#34;Desc_Pkg\u0026#34;: { \u0026#34;Close\u0026#34;: null, \u0026#34;Create\u0026#34;: null, \u0026#34;Transfer\u0026#34;: null }, \u0026#34;Desc_Z\u0026#34;: { \u0026#34;Ins\u0026#34;: [], // Cipher text input \t\u0026#34;Outs\u0026#34;: [{ // Cipher text output \t\u0026#34;AssetCM\u0026#34;: \u0026#34;0x3defeb7......afbe1ec80\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x218271ed71......4190115c0\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x29201d......1ad5faa5\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xe1f915......f09b23\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x03d8b......8c2e06\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x44231......f196841\u0026#34; }] }, \u0026#34;Ehash\u0026#34;: \u0026#34;0xe0624......fb4b00c\u0026#34;, \u0026#34;Fee\u0026#34;: { // Handling fee \t\u0026#34;Currency\u0026#34;: \u0026#34;0x0000000 ...... 00005345524f\u0026#34;, // Currency, you can use local_hexToCurrency to translate \t\u0026#34;Value\u0026#34;: \u0026#34;90000000000000\u0026#34; // Amount \t} , \u0026#34;From\u0026#34;: \u0026#34;0x3fb451 ...... 42be2a0\u0026#34;, // The sender\u0026#39;s collection code is also the address where excess gas is returned. \t\u0026#34;Sign\u0026#34;: \u0026#34;0x5fdd91 ...... d98405\u0026#34;, \u0026#34;Tx1\u0026#34;: { //SuperZK2.0 transaction content  \u0026#34;Ins_C\u0026#34;: [{...}] , // ciphertext input  \u0026#34;Ins_P\u0026#34;: [], //SuperZK1.0-2.0 conversion input  \u0026#34;Outs_C\u0026#34;: [{...}] , // ciphertext output  \u0026#34;Outs_P\u0026#34;: [{...}] // plaintext output  } } } , \u0026#34; error\u0026#34;: null } Get a transaction receipt\r#\r\rGet the result of the transaction. If the request is successful, it means that the transaction has been successfully packed into the block.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getTxReceipt\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x482a2f......1bd0a5c2\u0026#34; // Hash of a transaction  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { BHash: \u0026#34;0x33e2cb ...... e836e3b6b5\u0026#34;, // Packed block Hash \tBNum: 15 , // Packed block height \tNils: [ // The invalid code of the transaction List  \u0026#34;0x09f765a ...... d55fe482a6\u0026#34;, \u0026#34;0x51991f8e ...... 6fe2dfe4380a\u0026#34; ], Outs: [ // Root list of UTXO generated by the transaction  \u0026#34;0x3f89df0c ...... e14a300e3572d\u0026#34;, \u0026#34;0x3f9e217. ..... 94fdabde70a7 \u0026#34;, \u0026#34; 0x1d87a74a3 ...... 2d725144d6cd15 \u0026#34; ], Pkgs: null, PoolId: null, ShareId: null, State: 1, // Whether the smart contract runs successfully \tTxHash: \u0026#34;0x482a2f219d ...... a11bd0a5c2\u0026#34; // Transaction Hash \t} , \u0026#34;error\u0026#34;: null } Assembly transaction signature parameters\r#\r\rThe listing person needs to select the UTXO to be used to assemble the transaction. The assembly needs to provide the tracking key TK online, the flight_genTxParam method will obtain the current block witness, and automatically generate a change Out to balance the transaction amount. The output can be used local_signTxWithSk to sign.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_genTxParam\u0026#34;, \u0026#34;params\u0026#34;: [{ // Parameter 1: Pre-assembled transaction structure \t\u0026#34;From\u0026#34;: \u0026#34;0xb8d01 ...... 143099 \u0026#34;, // Change the payment code PKr, it needs to be matched with TK. \t\u0026#34;Gas\u0026#34;: 25000, // Max Gas consumption \t\u0026#34;GasPrice\u0026#34;: 1000000000, // Gas price, the minimum is 1Gta \t\u0026#34;Ins\u0026#34;: [\u0026#34;0x7b30c ...... 0fbb122e\u0026#34;], // Enter the root list of UTXO, Need to make sure it is UTXO under TK. \t\u0026#34;Outs\u0026#34;: [{ \u0026#34;Asset\u0026#34;: { // Asset object \t\u0026#34;Tkn\u0026#34;: { // Token object (homogenization token) \t\u0026#34;Currency\u0026#34;: \u0026#34;0x00000 ...... 005345524f\u0026#34;, // Currency Id, after removing 0 ASCII string \u0026#34;ZORRO\u0026#34; \t\u0026#34;Value\u0026#34;: \u0026#34;500000000000000000\u0026#34; // currency amount \t} }, \u0026#34;PKr\u0026#34;: \u0026#34;0x3b78d ...... 4603daa\u0026#34; // output receipt code PKr \t}] }, \u0026#34;tu1nEPY. ..... As8Ht4z \u0026#34; // Parameter 2: Tracking key TK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;Cmds\u0026#34;: { // Trading order \t\u0026#34;BuyShare\u0026#34;: null, \u0026#34;ClosePool\u0026#34;: null, \u0026#34;Contract\u0026#34;: null, \u0026#34;PkgClose\u0026#34;: null, \u0026#34;PkgCreate\u0026#34;: null, \u0026#34;PkgTransfer\u0026#34;: null, \u0026#34;RegistPool\u0026#34;: null }, \u0026#34;Fee\u0026#34;: { // transaction fee \t\u0026#34;Currency\u0026#34;: \u0026#34;0x0000000......0005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;25000000000000\u0026#34; }, \u0026#34;From\u0026#34;: { // Gas finds the recovery code PKr \t\u0026#34;PKr\u0026#34;: \u0026#34;0xb8d018f2 ...... 58143099\u0026#34;, \u0026#34;SKr\u0026#34;: \u0026#34;0x00000 ...... 00000\u0026#34;} , \u0026#34;Gas\u0026#34;: 25000, // Max gas consumption  \u0026#34;GasPrice\u0026#34;: 100000000, // Gas price \t\u0026#34;Ins\u0026#34;: [{ // Input list \t\u0026#34;Out\u0026#34;: { \u0026#34;Root\u0026#34;: \u0026#34;0x7b30cc81 ...... 10fbb122e\u0026#34;, \u0026#34;State\u0026#34;: { \u0026#34;Num\u0026#34;: 28, \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 31, \u0026#34;OutCM\u0026#34;: null, \u0026#34;Out_O\u0026#34;: null, \u0026#34;Out_Z\u0026#34;: { \u0026#34;AssetCM\u0026#34;: \u0026#34;0xa2a0f0......03745a9\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x68a9ed......cfc493\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0xc90dc......0ff58f\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0x9364f......4406a3\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x0341d6......57f941b0d\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x6230d427......02b51c2\u0026#34; }, \u0026#34;RootCM\u0026#34;: \u0026#34;0xff107b......dae30a2\u0026#34; }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x921b8......e44829\u0026#34; } }, \u0026#34;SKr\u0026#34;: \u0026#34;0x0000000......000000\u0026#34;, \u0026#34;Witness\u0026#34;: { \u0026#34;Anchor\u0026#34;: \u0026#34;0xde09cc......463503\u0026#34;, \u0026#34;Paths\u0026#34;: [ \u0026#34;0x1777ebb......b3cf9c2c\u0026#34;, ...... \u0026#34;0x3edc6......be382\u0026#34; ], \u0026#34;Pos\u0026#34;: \u0026#34;0x1f\u0026#34; } }], \u0026#34;Outs\u0026#34;: [{ // Output list \t\u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x00000000......000005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;500000000000000000\u0026#34; }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x00000000......0000000000\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0x3b78dd......4603daa\u0026#34; \u0026#34;Asset\u0026#34;: {// Automatically balanced change output{,} \t\u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x0000000......00005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;499975000000000000\u0026#34; }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x0000000......0000000\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xb8d018......143099\u0026#34; }] }, \u0026#34;error\u0026#34;: null } Broadcast transaction\r#\r\rAfter the call local_signTxWithSk is signed, the output transaction can be called and flight_commitTx broadcast to the whole network.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_commitTx\u0026#34;, \u0026#34;params\u0026#34;: [{ // output of local_signTxWithSk \t\u0026#34;Gas\u0026#34;: \u0026#34;0x61a8\u0026#34;, \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Hash\u0026#34;: \u0026#34;0x813f69b7d60fe694ddfd6bec36e2adcba773a4518ee02354bd8f2f339f004a2e\u0026#34;, \u0026#34;Tx\u0026#34;: {...} }] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: null, // Successfully return null  \u0026#34;error\u0026#34;: null, } Extract the corresponding Root through TK and Trace\r#\r\rWhen the transaction is signed, a Base is generated for each In in In_Z or In_C, and flight_trace2Rootthe root of UTXO corresponding to the In can be extracted through the three values of Base, Trace/NIL, and TK.\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_trace2Root\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0xbb793767f ...... 070f62f05\u0026#34;, // TK tracking key  \u0026#34;0x0207f1a29 ... ... e7652eda1\u0026#34;, // Trace original Trace field in Desc_Z.Ins  \u0026#34; 0x000000000 ...... 000000000\u0026#34; // Base value after signature  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0x51182a6775......f07d1e49a095\u0026#34;, // Root value  \u0026#34;error\u0026#34;: null, } "});index.add({'id':7,'href':'/docs/course/principle-of-anonymous-token/','title':"Anonymous tokens issuance principle",'content':"Anonymous Tokens Issuance Principle\r#\r\r ZORRO is the world\u0026rsquo;s first privacy blockchain system that supports Turing\u0026rsquo;s complete smart contracts. Since it supports smart contracts, it is certainly not a simple smart contracts + anonymous coins. ZORRO deeply integrates the advantages of both: the openness of smart contracts and the closeness of privacy systems. With the support of the two features, ZORRO\u0026rsquo;s smart contracts have very exciting features that can do some amazing things.\nThis article mainly explains the application of the Anonymous Token API provided by ZORRO in smart contracts, and briefly introduces the principle of the anonymous tokens at the beginning.\nUTXO and ACCOUNT\r#\r\rReaders who understand the structure of blockchain should know that the blockchain is a distributed ledger, each ledger account contains multiple transactions Tx, and each transaction contains multiple records. The smallest unit of the ledger account is record, and each record stores the inflow or outflow of the account\u0026rsquo;s assets. However, from the actual implementations, according to the different ways of asset outflow recording, the blockchain systems have evolved into two different accounting implementations, which are UTXO model and ACCOUNT model. These two models correspond to the models of Bitcoin and Ethereum respectively. ZORRO uses a more complex hybrid model.\nUTXO-Based Transactions\r#\r\rAs shown above, there are two types of records in the UTXO mode. For the transaction creator, they are Input and Output, which in the view of the transaction acceptor is Unspent Transaction Output (UTXO), until the transaction acceptor initiate another transaction and specify an Input to invalidate this UTXO. Records in transactions always link various inputs and outputs. In this mode, account is not necessary as a status summary.\nFor example, in the above picture, Alice received a transaction Tx 0, this transaction has an output of UTXO 0, and there are V ZORRO coins in UTXO 0, which can be recorded on her account [+V ZORRO , BALANCE=V]. Then she transfers the V ZORRO coins to Bob, so she generates a transaction Tx 1, this transaction has an Input to invalidate UTXO 0, then Alice\u0026rsquo;s ACCOUNT should record [-V ZORRO, BALANCE=0]. For Bob, he added a UTXO 1 with a value of V ZORRO. If his BALANCE before ACCOUNT is 0, his account can record [+V ZORRO, BALANCE=V].\nThis model has two advantages：\n Each transaction in UTXO model is independent of each other, which means that transactions under one account can be processed in parallel as long as the problem of double spend can be handled properly, and the capability of multi-core CPU can be fully utilized. UTXO is essentially a record form based on history, both a process and a result, so it has great advantages in some applications where proofs need to be generated. This is why the blockchain systems with CT(Conﬁdential Transactions) features are basically UTXO mode.  ACCOUNT-Based Transactions\r#\r\rThe UTXO model mentioned above said that each account can generate a temporary ACCOUNT as a status summary. In UTXO model, this account is temporary and not necessary. In the ACCOUNT model, each asset inflow and outflow record in the transaction references ACCOUNT instead of UTXO, the record Input indicates that the assets of the ACCOUNT are added, and the record Output indicates that the assets of the ACCOUNT are subtracted. In this model, the ACCOUNT entity is required. Without this ACCOUNT, all records do not make sense to the ledger.\nAs mentioned above, for example, Alice has previously received a transaction Tx 0, this transaction has an output value of Output 0 for V ZORRO coins, and her ACCOUNT will add V ZORRO coins. At this time she wants to transfer out V ZORRO coins to Bob, then she initiates a transaction, the Input of the transaction points to her ACCOUNT, the value is V ZORRO coins, and the Output 1 points to Bob\u0026rsquo;s ACCOUNT, the value is also V ZORRO coins. When the transaction is processed by the system, the assets in both ACCOUNT will be directly added or subtracted. In this model, Alice can\u0026rsquo;t distinguish whether the Input is the ZORRO coins transfered by Output 0 or the ZORRO coins that was previously stored in the ACCOUNT.\nThe ACCOUNT model also has two advantages\n ACCOUNT model directly add or subtract the assets in an independent account, and can add or subtract any value of assets in an account with only one record. Therefore, the generated record size is much smaller than the record generated by UTXO in the same situation. The ACCOUNT model is state-based, Input and Output are processes, and ACCOUNT is the result, so it is easy to implement the Turing machine, that is why the blockchain that supports Turing\u0026rsquo;s complete smart contracts mostly uses the ACCOUNT model.  ZORRO\u0026rsquo;s Hybrid Model\r#\r\rZORRO applies UTXO and ACCOUNT models together, using UTXO model where CT(Conﬁdential Transactions) are required, and using ACCOUNT model where smart contracts need to be run. ZORRO seamlessly integrates these two models through trading, consensus, and Pedersen Commitment algorithms, enabling smart contracts to perform surprisingly.\n The smart contracts mentioned in this article corresponds to the concept of Online Smart Contracts in ZORRO\u0026rsquo;s white paper.\n Anonymous Transaction Structure\r#\r\rIn the BETANet network, ZORRO\u0026rsquo;s general transactions are mandatory for anonymity. Because if any non-anonymous transaction can be allowed, the privacy of the users who wants to use the anonymous feature will not be guaranteed in the associated transaction. In addition, if you want to publicize information such as your own assets, it is recommended to use smart contracts to disclose some information to a limited extent.\n When the MAINNet is released, ZORRO will achieve a balance of privacy and execution speed by selecting the privacy level.\n Transactions Tx\r#\r\rZORRO\u0026rsquo;s confidential transactions Tx have an anonymous input set Z ins, an anonymous output set Z outs, a normal output set O outs, and a temporary address From. Z ins is completely anonymous, making it impossible for third-party observers to find out the source and content. Z outs is completely anonymous UTXO, only the receiver can view and use its content, the content carried by the O Outs is not hidden, and it refers to the receiver in two situations: one is pointing to a smart contract address, and the other is pointing to a temporary address. From represents the sender of the transaction and is also a temporary address. Therefore, the whole Tx cannot make the third-party observers determine who is the real user, and the information such as assets carried in it is also hidden to the greatest extent.\nInput Z ins\r#\r\rIn the input set Z ins of the ZORRO transactions, each input is anonymous, including the Id of the source UTXO and the asset information carried. Each input is converted to a Proof generated by zero-knowledge proofs ZKP. The Proof pointed to a particular UTXO hidden in a huge UTXO sequence, which is part of the ZORRO history, all details hidden by Proof. The verifier can confirm whether the input is valid by Proof without knowing the details. This way of hidding data is similar to the ring signature, but the Proof is much smaller than the ring signature, and using the zero knowledge proofs, the data range used to hide the UTXO collections is much larger than the ring signature.\nTwo types of output outs\r#\r\rThe outputs contained in the ZORRO transaction are divided into two forms, zero-knowledge output Z out and normal output O out.\nZ out Z out points to the temporary address PKr, and the temporary address can only be decrypted by the receiver. Since each temporary address is different, no third party can identify the Z out real point address. Z out also carries the encrypted information Encrypt Info of the asset, which can only be decrypted by the party holding the receiver\u0026rsquo;s private key. And OutCM is the output commitment, only the parties of the transaction can reproduce the computing process of OutCM. OutCM plays a crucial role in proving that Z out is referenced by ins.\nO out\nThe PKr pointed to by O out has two forms, one is initiated by a smart contract and points to the temporary address of the common account. The other is initiated by a normal account, pointing to the address of the smart contract. Due to the randomness of the temporary address, the third party cannot know the identity of the receiver, and the asset information carried by O out is public.\nThe Balance of inputs and outputs\r#\r\rTx packages ins, Z outs, and O outs together. How to prevent malicious attackers from tampering with the data and ensuring asset security? By introducing perdesen commitment, its homomorphic encryption feature enables verifiers to confirm that Balance must be balanced without knowing the details of the information, that is, the input is equal to the output.\nIn addition, in order to prevent malicious attackers from tampering with O outs, we use the random feature of perdesen commitment to sign Tx Hash with the random part of Balance. In this way, each input and output can be computed independently and then packaged together by B-Sign.\nTransaction Sender From\r#\r\rWhen the output of a transaction points to a smart contract, the smart contract sometimes needs to output resources to a given account based on the written rules. At this time, the temporary address From is the place where the output resources are received. From is determined when the transaction is generated and used only once. Other than the sender of the transaction, the third parties cannot locate the identity of the sender.\nPrinciple of Issuing Anonymous Tokens\r#\r\rToken Assets\r#\r\rToken, also known as the “homogeneous pass”, is an asset form recognized within ZORRO system. The same kind of tokens can be arbitrarily divided and mixed, specifically the so-called \u0026ldquo;coins\u0026rdquo;. As the first currency of the ZORRO system, ZORRO coins are also a type of tokenss in essence. For Token assets, except for handling fees, which can only be paid in ZORRO coins, they are treated the same within the ZORRO system, and their privacy and security are ensured by consensus.\n Unlike the Token concept in Ethereum, the Tokens in Ethereum are only symbols of the internal records of the smart contracts, and ETH is the Token asset that is actually running inside Ethereum.\n Token Name\r#\r\rEach Token has a name. After the ZORRO system is initialized, there is only one registered token named ZORRO by default. When a smart contract issues an anonymous token, a globally unique string must be registered with the ZORRO system as the name of the token. The token name can greatly improve the readability of your issued assets.\nAnonymous Token Assets\r#\r\rZORRO\u0026rsquo;s smart contracts have a very powerful feature, which is that you can issue an \u0026ldquo;anonymous Token\u0026rdquo; at will. Of course, the premise is that you need a token name that has never been registered. Once the anonymous Tokens are successfully issued, the smart contract can send the tokens to the temporary address PKr of a normal account in the form of a normal transaction. At this time, thess sent tokens will be separated from the smart contract account in the form of UTXO, and transfered into the user\u0026rsquo;s account like ZORRO coins , thus being protected by ZORRO\u0026rsquo;s privacy mechanism.\n The issue of ZORRO coins is achieved by miners. The process is similar to the mechanism for smart contracts to issue anonymous tokens. It is the built-in tokens distribution function of ZORRO.\n "});index.add({'id':8,'href':'/docs/course/how-to-staking-using-zro/','title':"How to start ZORRO Staking on zro",'content':"How to start ZORRO Staking on zro ?\r#\r\r  The Staking feature is supported by full-node programs\nThis article is mainly provided for users of full-node background program. Users of the wallet with a graphical interface, please wait for the subsequent documentation.\nStaking function will be effective after the height of block 117600\n A brief description of the process of Staking\r#\r\r  POS miners can buy voting shares in the shares pool.\n Shares have a pool of shares with no upper limit. The price of the shares is dynamically adjusted according to the size of the shares pool. The share price change within the pool size of 326592 is relatively balanced. After the stock pool size exceeded 326,592, the share price rose sharply.    After the POW miner calculates the block HASH, he need to randomly select 3 shares in the shares pool and broadcast the ballot information.\n  After receiving the ballot information of their own, the POS miner immediately broadcasts the voting information with his signature.\n  After receiving the voting information of the POS miner, the POW miner puts the signature into the block header information.\n  If more than 2 votes are correctly voted, the POW miner will broadcast the block and complete the block process.\n  POS miner can choose SOLO voting or StakingNode proxy voting.\n  Each block reward are divided into POW rewards and POS rewards.\n The ratio of POW rewards to POS rewards is 4 : 4 The amount of POW rewards and POS rewards varies independently of each difficulty.    POS rewards are divided into Solo voting and StakingNode proxy voting.\n The income ratio of Solo voting and StakingNode proxy voting is 3 : 4    After the voting process is completed, the reward and principal will be returned within the latest payment cycle (about 1 week).\n  SOLO Staking\r#\r\rYou should have a full-node program (zro) and have a certain number of ZORRO tokens to make a SOLO vote and get a proportion of 3 POS rewards.\nPrerequisites for SOLO\r#\r\r A continuously running full-node program (zro), which has completed the block synchronously. There is a certain amount of ZORRO coins in the account.  Steps\r#\r\r1. Summary of steps\r#\r\r Confirm that there are enough ZORRO coins to buy shares.  The principal will also be returned when the proceed is released or the share is expired   Create a voting account. Enable automatic voting function (unlock voting account).。 Buy shares in the shares pool. View current share status. Confirm revenue.   Note: the account key must be backed up. Ordinary users can copy the keystore for backup or export mnemonics:\n  \u0026gt; personal.exportMnemonic(zorro.accounts[0]) export account mnemonic 5bEgN9YL......Xrpti4zeamkdD16C Passphrase: 1234 // Password \u0026#34;casino crys ... ... en unaware route\u0026#34; The mnemonics can be imported like this:\n\u0026gt; personal.importMnemonic(\u0026#34;casino cry ... ... re route\u0026#34;,\u0026#34;1234\u0026#34;) //1234 is password  2. Confirm the asset account\r#\r\rFor safety, ZORRO\u0026rsquo;s asset account and voting account are separated, principal and reward will only be handled by asset account, and we now confirm the asset account.\n\u0026gt; zorro.accounts[0] \u0026#34;5bEgN9YLqC......4zeamkdD16C\u0026#34; // PK \u0026gt; web3.fromTa(zorro.getBalance(zorro.accounts[0]).tkn.ZORRO) 10 //20 ZORRO coins 3. Create a voting account\r#\r\rThe voting account does not process assets and is only used for voting signatures.\n\u0026gt; personal.newAccount(\u0026#34;1234\u0026#34;) \u0026#34;2tuxyM5uL4......Ce5xNPokr\u0026#34; \u0026gt; zorro.accounts[1] \u0026#34;2tuxyM5uL4......Ce5xNPokr\u0026#34; // PK The voting account needs to be permanently unlocked so that voting can be conducted quickly after being drawn.\n\u0026gt; personal.unlockAccount(zorro.accounts[1],\u0026#34;1234\u0026#34;,0) Note: SOLO Staking needs to ensure the stability of the entire node network, otherwise the vote may MISS.\n4. View the shares pool status\r#\r\r  The interfaces related to staking are in the stake object.\n\u0026gt; stake { sharePoolSize: \u0026#34;0x0\u0026#34;, // Current size of the shares pool  sharePrice: \u0026#34;0x1bc16d674ec80000\u0026#34;, // Current share price  buyShare: function(), closeStakePool: function(), getShare: function(), getSharePoolSize: function(callback), getSharePrice: function(callback), modifyStakePoolFee: function(), modifyStakePoolVote: function(), myShare: function(), poolState: function(), registStakePool: function(), stakePools: function() }   View the current shares pool information\n\u0026gt; web3.fromTa(web3.toDecimal(stake.sharePrice)) \u0026#34;2\u0026#34; // The current share price is 2 ZORRO \u0026gt; web3.toDecimal(stake.sharePoolSize) 0 // There are 0 shares in the current shares pool.   5. Subscribe for shares\r#\r\r  Estimate the number of shares that can be purchased\n Since the share price increases linearly with the size of the pool, it is necessary to estimate the number of shares that can be purchased first.  \u0026gt; stake.estimateShares({ from:zorro.accounts[0], //Asset account  vote:zorro.accounts[1], //Voting account  value:web3.toTa(20) //Total amount that can be staked }) { avPrice: \u0026#34;0x1bc6ab6c2dfe1734\u0026#34;, //Average share price  basePrice: \u0026#34;0x1bc16d674ec80000\u0026#34;, //Base share price  total: \u0026#34;0x9\u0026#34; //Purchasable quantity }   Subscription，from: Asset account, vote: voting account, value: subscription fund\n\u0026gt; stake.buyShare({from:zorro.accounts[0],vote:zorro.accounts[1],value:web3.toTa(20)}) \u0026#34;0xac137baf4cd195....17c1fcb3edae4d25\u0026#34; \u0026gt; zorro.getTransactionReceipt(\u0026#34;0xac137baf4....cb3edae4d25\u0026#34;) { .... poolId: null, shareId: \u0026#34;0xb5b01116f......71015afc6f\u0026#34;, //ID of Purchased shares  .... }   Check the status of the shares purchase\n\u0026gt; stake.getShare(\u0026#34;0xb5b01116f......71015afc6f\u0026#34;) { addr: \u0026#34;5bEgN9YLq......4zeamkdD16C\u0026#34;, id: \u0026#34;0xb5b01116f3e8......2a08b28171015afc6f\u0026#34;, // ID of Purchased  missed: 0, num: 1, price: 2001844456911510800, // The average price  returnAmount: 20814755655292090000, // Amount refunded  status: 0, total: 9, // Number of shares  tx: \u0026#34;0x47a87164f......13e422efee\u0026#34;, voteAddr: \u0026#34;2tuxyM5uL4ZDk......4xdTPCe5xNPokr\u0026#34; // Collection code of voting account }   View my total shares\n\u0026gt; stake.myShare(\u0026#34;5bEgN9YLqCBN9......pti4zeamkdD16C\u0026#34;) [{ addr: \u0026#34;5bEgN9YLqCB......rpti4zeamkdD16C\u0026#34;, expired: 0, // Number of expired shares  missed: 0, // Vote miss number  pools: null, remaining: 10, // The remaining number of shares  shareIds: [ // List of shares IDs I own  \u0026#34;0x3f2ae......a0c656d9b7b7\u0026#34;, \u0026#34;0x58395b1......cfa4141d\u0026#34;, \u0026#34;0xb5b011......171015afc6f\u0026#34; ], total: 30, // My total number of shares  voteAddr: [\u0026#34;2tuxyM5uL4ZDkfp......Vtw4xdTPCe5xNPokr\u0026#34;] // My vote ID }]   6. View account balance\r#\r\r\u0026gt; web3.fromTa(zorro.getBalance(zorro.accounts[0]).tkn.ZORRO) // Asset account 339.980079865355683522 \u0026gt; zorro.getBalance(zorro.accounts[1]) //Voting account {} How to create a Staking Node\r#\r\rDue to unstable personal network, or unable to open the full-node continuously, then it is possible to entrust Staking Node to vote on behalf of them.\nHere\u0026rsquo;s how to create a Staking Node for voting.\nPrecondition\r#\r\r Have a continuous online full-node program (zro). Have an account with a 200,000 ZORRO balance. Have a good network environment.  Steps\r#\r\r1. Step summary\r#\r\r Confirm that there are 200,000 ZORRO coins used for pledge.  When the Node is closed, the principal will be returned.   Create a proxy voting account. Turn on the automatic voting function (unlock the voting account). Pledge ZORRO coins to open Staking Node View the current node delegation status. Confirm revenue.  2. Confirm asset account\r#\r\r\u0026gt; zorro.accounts[0] \u0026#34;5bEgN9YLqC......4zeamkdD16C\u0026#34; \u0026gt; web3.fromTa(zorro.getBalance(zorro.accounts[0]).tkn.ZORRO) 200000.980079865355683522 3. Create a proxy voting account\r#\r\r\u0026gt; personal.newAccount(\u0026#34;1234\u0026#34;) \u0026#34;2tuxyM5uL4......w4xdTPCe5xNPokr\u0026#34; \u0026gt; zorro.accounts[1] \u0026#34;2tuxyM5uL4......Ce5xNPokr\u0026#34; 4. Enable automatic voting function (unlock the voting account)\r#\r\rVoting accounts need to be permanently unlocked so that they can be voted quickly after being drawn.\n\u0026gt; personal.unlockAccount(zorro.accounts[1],\u0026#34;1234\u0026#34;,0) Note: StakingNode needs to ensure that the entire node network is stable, otherwise it may lead to voting MISS, and the vote of MISS may lead to an increase in the principal locking time of StakingNode.\n5. Register Staking Node by pledging ZORRO coins\r#\r\rThe client needs to connect more than 10 peers to open the command to register the staking node.\n\u0026gt; admin.peers.length 15 Start registering StakingNode, note that in this example accounts[0] has 200,000 ZORRO coins, which is a asset account.\n\u0026gt; stake.registStakePool({ from:zorro.accounts[0], //asset account  vote:zorro.accounts[1], //voting account  value:web3.toTa(200000), //Registered fund  fee:web3.toHex(2500) // Draw, 7500 represents 75%, 2500 represents 25%, and the maximum draw is 75%. }) \u0026#34;0xecb3b5b235....8d35d7d1651\u0026#34; //Register generated transaction hash You can view the ID of the registered StakingNode by viewing the transaction receipt.\n\u0026gt; zorro.getTransactionReceipt(\u0026#34;0xecb3b5b....7d1651\u0026#34;) { ...... poolId: \u0026#34;0xb1e20b74......2b35888176d\u0026#34;, //StakingNode ID  shareId: null, ...... } **Note:**StakingNode The pledge of the principal needs to be locked for 1 months before it can be unlocked, but it must be closed after closing the staking node and no shares point to the staking node.\n6. View current node delegation status and revenue\r#\r\rThe status of StakingNode can be viewed via the poolState method.\n\u0026gt; stake.poolState(\u0026#34;0xb1e20b......88176d\u0026#34;) { choicedNum: \u0026#34;0x0\u0026#34;, // Number of shares selected  closed: false, // Is Staking Node closed?  createAt: \u0026#34;0x11\u0026#34;, // Staking Node created time  expireNum: \u0026#34;0x0\u0026#34;, // Number of expired entrusted shares of Staking Node  fee: \u0026#34;0xfa0\u0026#34;, // Withdrawal of Staking Node  id: \u0026#34;0xb1e20b7......88176d\u0026#34;, //Staking Node的ID  idPkr: \u0026#34;2E7uXmU9......GeQyGBzSvWE\u0026#34;, lastPayTime: \u0026#34;0x0\u0026#34;, // Lastest payment time  missedNum: \u0026#34;0x0\u0026#34;, // Missed votes  own: \u0026#34;5bEgN9YLqC......4zeamkdD16C\u0026#34;, shareNum: \u0026#34;0x0\u0026#34;, // Total number of shares  tx: \u0026#34;0xecb3b5b......d1651\u0026#34;, voteAddress: \u0026#34;2tuxyM5uL4......w4xdTPCe5xNPokr\u0026#34;, wishVoteNum: \u0026#34;0x0\u0026#34;, profit: \u0026#34;0x100\u0026#34; } How to select Staking Node as a voting proxy to vote for yourself\r#\r\rOrdinary users only need to specify the Staking Node when they purchase the shares, so they can enjoy the convenient voting service without deploying the full-node program.\n1.Query the Staking Node list of the whole network\r#\r\r\u0026gt; stake.stakePools() [{ choicedNum: \u0026#34;0x0\u0026#34;, // Number of shares selected  closed: false, // Whether to be closed  createAt: \u0026#34;0x0\u0026#34;, expireNum: \u0026#34;0x0\u0026#34;, // Number of expired shares  fee: \u0026#34;0xfa0\u0026#34;, // Draw proportion  id: \u0026#34;0xb1e20b7......2b35888176d\u0026#34;, // StakingNode ID  idPkr: \u0026#34;2E7uXm......yGBzSvWE\u0026#34;, lastPayTime: \u0026#34;0x0\u0026#34;, missedNum: \u0026#34;0x0\u0026#34;, // Missed votes  own: \u0026#34;4ujQrFsaYq......WZzxtnqgTsL\u0026#34;, shareNum: \u0026#34;0x0\u0026#34;, // Number of shares  tx: \u0026#34;0xecb3b5b......35d7d1651\u0026#34;, voteAddress: \u0026#34;21F6gyEUw......zMZ5VtGL2\u0026#34;, wishVoteNum: \u0026#34;0x0\u0026#34; }, { choicedNum: \u0026#34;0xac\u0026#34;, closed: false, createAt: \u0026#34;0x0\u0026#34;, expireNum: \u0026#34;0x30d\u0026#34;, fee: \u0026#34;0x123b\u0026#34;, id: \u0026#34;0xc48e455......2af708a\u0026#34;, idPkr: \u0026#34;2WCHu3......jbFrXWE\u0026#34;, lastPayTime: \u0026#34;0x12b404\u0026#34;, missedNum: \u0026#34;0x60\u0026#34;, own: \u0026#34;2WCHu3bM......jbFrXWE\u0026#34;, shareNum: \u0026#34;0x4fe\u0026#34;, tx: \u0026#34;0xb9a0a......dc0212\u0026#34;, voteAddress: \u0026#34;JyRPyD8n......bucfZbRH\u0026#34;, wishVoteNum: \u0026#34;0x0\u0026#34; }] 2. When buying shares, choose to vote on behalf of a staking node.\r#\r\r\u0026gt; stake.buyShare({ from:zorro.accounts[0], vote:zorro.accounts[0], pool:\u0026#34;0xc48e45......af708a\u0026#34;, // Select StakingNode ID  value:web3.toTa(2000) }) \u0026#34;0xb524ec5......b8d511b0b\u0026#34; \u0026gt; zorro.getTransactionReceipt(\u0026#34;0xb524e......8d511b0b\u0026#34;) { ...... shareId: \u0026#34;0x9e415fa4......94e4eef\u0026#34;, // Share ID purchased  ...... } 3. Status of Staking Node confirming a share\r#\r\r\u0026gt; stake.getShare(\u0026#34;0x9e415f......94e4eef\u0026#34;) { addr: \u0026#34;4ujQrFsaY......zxtnqgTsL\u0026#34;, id: \u0026#34;0x9e415f......994e4eef\u0026#34;, missed: 0, num: 723, pool: \u0026#34;0xc48e4557......ec62af708a\u0026#34;, // StakingNode ID selected by this share  price: 2739073884442371600, returnAmount: 23602264528913793000, // Income  status: 0, total: 730, tx: \u0026#34;0xb524ec5......b8d511b0b\u0026#34;, voteAddr: \u0026#34;4ujQrFsaYq......qWZzxtnqgTsL\u0026#34; } Return of principal\r#\r\r The design of ZORRO\u0026rsquo;s Staking will not confiscate or destroy the ZORRO coins of any user. When the following happens, the principal of the shares will be returned  The shares that complete the voting process will be returned at the same time as the block award is given. If the shares have not been selected by any miners for more than one month, the principal will be refunded. Shares that were selected but did not respond(MISS) will be returned in the third month.   When the following conditions are all met, the StakingNode principal will be returned.  StakingNode is closed by the owner StakingNode registration completed for one month There are no more shares in the shares pool entrusted to StakingNode    "});index.add({'id':9,'href':'/docs/','title':"Docs",'content':""});})();